{"pageProps":{"allPostsData":[{"id":"type-and-coercion-js","title":"Types and Coercion in JS","description":"A quick guide to types and coercion in JavaScript.","date":"2022-08-15","content":"<p>Most of you are familiar with the saying everyone quotes, which is “Everything in Javascript are Objects”. What if I tell you that’s not entirely true? In this blog, we will be taking a deep dive into types in Javascript. People try to stay away from types, especially in dynamically typed language but sometimes not knowing about types can cause some real bugs in your code. We often experience some weird behavior from our program as shown below.</p>\n<pre><code>true + true; // 2\r\n[] + ![]; // false\n</code></pre>\n<p>We see this kind of joke all around the internet and people say how poorly javascript is designed and all those stuff. But does that really make sense? The reason for making fun of that is basically we don’t know enough about javascript behavior and we see them as some magic or black box. What our response should be as a developer is to know our tools effectively and know the corner cases of them and henceforth avoid them while writing our code. There are corner cases in every big system and they can’t be avoided at all. The reason we don’t know about all these corner cases is that we hardly know what is actually being done by the javascript and rather we make some assumptions. If you want to look at corner cases of some other programming language visit here <a href=\"https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/\">https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/</a>.</p>\n<h3>Note</h3>\n<p>There will be a lot of new and weird things you will notice throughout the blog and it is sure that you will not get all the concepts by reading it once. What I will suggest is to learn slowly and try to look at all the code snippets shared below. Also, check all the links for the specs to get a clearer insight.</p>\n<p>Let’s get back to the quote</p>\n<p>However in the spec we can clearly see Javascript has types also called as primitive types</p>\n<p>Link: <a href=\"https://262.ecma-international.org/9.0/#sec-ecmascript-language-types\">https://262.ecma-international.org/9.0/#sec-ecmascript-language-types</a></p>\n<h3>Let’s dig into the primitive types</h3>\n<p>The Spec defines the following primitive types as follows</p>\n<ol>\n<li><code>undefined</code>: it has only one value that is undefined and any variable that has not been assigned a value has the value <code>undefined</code></li>\n<li><code>null</code>: it has only one value that is null and it represents the intentional absence of any object value</li>\n<li><code>boolean</code>: The boolean type represents a bool value that is either true of false</li>\n<li><code>string</code>: The string type is the set of all ordered sequences of zero or more 16-bit unsigned <a href=\"https://262.ecma-international.org/11.0/#integer\">integer</a> values (“elements”) up to a maximum length of 2 raise to the power 53 - 1 elements.</li>\n<li><code>number</code>: a set of all possible Number values including the special “Not-a-Number” (NaN) value, positive infinity, and negative infinity. And number value is a primitive value corresponding to a double-precision 64-bit binary format <a href=\"https://262.ecma-international.org/11.0/#sec-bibliography\">IEEE 754-2019</a> value</li>\n<li><code>object</code>: An Object is logically a collection of properties. Each property is either a data property or an accessor property like dot notation and so on.</li>\n<li><code>bigInt</code>: a set of all possible BigInt values that is a primitive value corresponding to an arbitrary-precision <a href=\"https://262.ecma-international.org/11.0/#integer\">integer</a> value</li>\n<li><code>symbol</code>: The Symbol type is the set of all non-String values that may be used as the key of an Object property. It is less used in normal development and is usually used in frameworks and library</li>\n</ol>\n<p>That’s a lot of academic kind of stuff up there so let’s see some code to know the types of variables using the <code>typeof</code> operator.</p>\n<pre><code>let v;\r\nconsole.log(typeof v); // undefined\r\nv = \"1\";\r\nconsole.log(typeof v); // string\r\nv = 2;\r\nconsole.log(typeof v); // number\r\nv = true;\r\nconsole.log(typeof v); // boolean\r\nv = {};\r\nconsole.log(typeof v); // object\r\nv = Symbol();\r\nconsole.log(typeof v); // symbol\r\nv = [1, 2, 3, 4];\r\nconsole.log(typeof v); // object\r\nv = () => \"hello\";\r\nconsole.log(typeof v); // function\r\nv = null;\r\nconsole.log(typeof v); // object\r\nv = 16n;\r\nconsole.log(typeof v); // bigint\r\n// corner case\r\nv = null;\r\nconsole.log(typeof null); // object\n</code></pre>\n<h2>Kinds of Emptiness</h2>\n<p>Let’s see about the kind of emptiness javascript offers:</p>\n<ul>\n<li>undeclared: a variable that has never been created in any scope</li>\n</ul>\n<pre><code>console.log(typeof m); // undefined\r\n// here in this case m doesn't even exist and still we get undefined becuase of javascript\r\n// pretend as if you can declare the variable after and is currently undeclared\n</code></pre>\n<ul>\n<li>undefined : there is a variable and at the moment it has no value</li>\n</ul>\n<pre><code>let v;\r\nconsole.log(typeof v); // undefined\n</code></pre>\n<ul>\n<li>uninitialized: for block scope variables they are not initialized or set to undefined and you cannot allow touching (tdz) and hence are in an uninitialized position. Learn more : <a href=\"https://www.freecodecamp.org/news/javascript-temporal-dead-zone-and-hoisting-explained/\">https://www.freecodecamp.org/news/javascript-temporal-dead-zone-and-hoisting-explained/</a></li>\n</ul>\n<h3>Some Special Value</h3>\n<h3>NaN (<code>not a number</code>)</h3>\n<ul>\n<li>NaN is called as <code>not a number</code> but if talking more specifically we can say it tells us about not a valid number according to IEEE 764: https://en.wikipedia.org/wiki/IEEE_754</li>\n<li>Here in the below example, we are doing a subtract operation with a string and a number which results in <code>NaN</code> and one most important property of <code>NaN</code> is that they are not equal to itself which is kind of weird but that’s how it is.</li>\n<li>Here in the example we also see that the <code>typeof NaN</code> returns a number. Hence we can conclude that <code>NaN</code> is a type of number but an invalid number.</li>\n</ul>\n<pre><code>// IEEE 764 : https://en.wikipedia.org/wiki/IEEE_754\r\nlet totalApples = 10;\r\nlet applesDistributed = \"five\";\r\nlet remainingApple = totalApples - applesDistributed;\r\n\r\nconsole.log(remainingApple); // NaN\r\nconsole.log(remainingApple === remainingApple); // false\r\nconsole.log(typeof remainingApple); // number\n</code></pre>\n<ul>\n<li>To check whether a value is <code>NaN</code> we have two functions, one is called <code>isNaN()</code> and the other is <code>Number.isNan()</code>. Let’s see what we get using <code>isNaN()</code></li>\n</ul>\n<pre><code>let greet = \"Hello world\";\r\n\r\n// using isNan\r\nconsole.log(typeof greet); // string\r\nconsole.log(isNaN(greet)); // true\n</code></pre>\n<ul>\n<li>In the above example, we can see that typeof greet is string however in the next line when we use isNaN on it returns true as if the greet is a <code>NaN</code> value. That’s weird. Isn’t it?</li>\n<li>Let’s see why it happens to link to the spec: <a href=\"https://262.ecma-international.org/11.0/#sec-isnan-number\">https://262.ecma-international.org/11.0/#sec-isnan-number</a> . As we can see that in spec it tells us that it first performs an abstract operation which we will learn about in a bit called ToNumber and then whatever value is returned is checked whether it is not equal to itself or not. If it is not equal to itself then we can conclude that the number is <code>NaN</code>. Let’s see it in action by writing our own isNaN()</li>\n</ul>\n<pre><code>function myIsNaN(num) {\r\n  if (typeof num !== \"number\") {\r\n    num = Number(num);\r\n    console.log(num);\r\n    return num !== num;\r\n  }\r\n}\r\n\r\nlet greet = \"Hello world\";\r\n\r\n// using isNan\r\nconsole.log(typeof greet); // string\r\nconsole.log(isNaN(greet)); // true\r\n\r\n// using myIsNaN\r\nconsole.log(myIsNaN(greet)); // true\n</code></pre>\n<ul>\n<li>You can clearly see why it treat string as <code>NaN</code> due to the abstract ToNumber operation.</li>\n<li>In order to fix this we get another utility function in Javascript called as <code>Number.isNaN</code> let's use it to learn its behavior</li>\n</ul>\n<pre><code>// IEEE 764 : https://en.wikipedia.org/wiki/IEEE_754\r\nlet totalApples = 10;\r\nlet applesDistributed = \"five\";\r\nlet remainingApple = totalApples - applesDistributed;\r\n\r\nconsole.log(remainingApple); // NaN\r\nconsole.log(remainingApple === remainingApple); // false\r\nconsole.log(typeof remainingApple); // number\r\n\r\n// using Number.isNaN()\r\nconsole.log(Number.isNaN(applesDistributed)); // false\r\nconsole.log(Number.isNaN(remainingApple)); // true\n</code></pre>\n<ul>\n<li>Here we see that as it is written in the specs that <a href=\"https://262.ecma-international.org/11.0/#sec-number.isnan\">https://262.ecma-international.org/11.0/#sec-number.isnan</a> and it shows that it doesn’t coerce the thing which is not a number type and directly return false.</li>\n</ul>\n<h3>Negative Zero <code>-0</code></h3>\n<p>We also have another special value which is <code>-0</code> and it also has some weird corner cases. Let’s see them through code</p>\n<pre><code>let trendRate = -0;\r\n\r\nconsole.log(trendRate === -0); // true\r\nconsole.log(trendRate.toString()); // 0\r\nconsole.log(trendRate === 0); // true\r\nconsole.log(trendRate &#x3C; 0); // false\r\nconsole.log(trendRate > 0); // false\r\n\r\n// to check negative zero we can use Object.is()\r\nconsole.log(Object.is(trendRate, -0)); // true\r\nconsole.log(Object.is(trendRate, 0)); // false\r\n\r\n// using Math.sign()\r\nconsole.log(Math.sign(-0)); // -0\r\nconsole.log(Math.sign(0)); // 0\r\nconsole.log(Math.sign(-3)); // -1\r\nconsole.log(Math.sign(3)); // 1\n</code></pre>\n<p>Here in the above example, we can see how weird it behaves while working with <code>-0</code> and how to handle that corner case.</p>\n<p>We also see that <code>Math.sign()</code> also return weird result in case of <code>0</code> and <code>-0</code> .</p>\n<h2>Abstract operation</h2>\n<p>The operations fundamentally perform the task of type coercion. They are not a specific type of function or something like that but they are a conceptual thing that let us understand coercion thing. Link for the specs here: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-operations\">https://262.ecma-international.org/11.0/#sec-abstract-operations</a> . There is a bunch of abstract operation that is performed on certain cases but we will look at a few that are more important to know in our day-to-day programming. We will use typecasting to demonstrate the abstract operation</p>\n<ol>\n<li><strong>ToNumber(value)</strong>: This operation converts the argument value to the type of number according to this table <a href=\"https://262.ecma-international.org/11.0/#table-11\">https://262.ecma-international.org/11.0/#table-11</a></li>\n</ol>\n<pre><code>// here we are using the build-in object to do the typecast\r\nconsole.log(Number(\"\")); // 0\r\nconsole.log(Number(\"0\")); // 0\r\nconsole.log(Number(\"-0\")); // -0\r\nconsole.log(Number(\"009\")); // 9\r\nconsole.log(Number(\"3.14\")); // 3.14\r\nconsole.log(Number(\"0.\")); // 0\r\nconsole.log(Number(\".0\")); // 0\r\nconsole.log(Number(\".\")); // NaN\r\nconsole.log(Number(\"0xaf\")); // 175\r\nconsole.log(Number(false)); // 0\r\nconsole.log(Number(true)); // 1\r\nconsole.log(Number(null)); // 0\r\nconsole.log(Number(undefined)); // NaN\r\nconsole.log(Number([\"\"])); // 0\r\nconsole.log(Number({})); // NaN\r\nconsole.log(Number([1, 2])); // NaN\r\nconsole.log(Number({ a: \"hello\" })); // NaN\n</code></pre>\n<ol>\n<li><strong>ToPrimitve(value, hint)</strong>: This operation is performed to covert any not primitive value to a primitive value and does it in two steps. First, it checks valueOf(), and then it converts it to ToString() to get the desired result. Link for further reading <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf</a></li>\n<li>ToString(value): This operation converts the argument value to the type of number according to this table <a href=\"https://262.ecma-international.org/11.0/#table-12\">https://262.ecma-international.org/11.0/#table-12</a>. Below represents some corner cases that create some exceptions when we will look into the equality and coercion section of the blog.</li>\n</ol>\n<pre><code>let c = -0;\r\nlet arr = [1, 2, 3, 4];\r\nlet arr1 = [null, undefined, true, 1, \"1\"];\r\nlet obj = { apple: \"red\" };\r\nconsole.log(arr.toString()); // \"1,2,3,4\"\r\nconsole.log(c.toString()); // \"0\"\r\nconsole.log(arr1.toString()); // \",,true,1,1\" | undefined and null are ignored\r\nconsole.log(obj.toString()); // [object Object]\n</code></pre>\n<ol>\n<li>ToBoolean(value): This operation covert any value to boolean type and it basically just does a lookup to the table given below and if any of the value does fall in the falsy side it returns false and every other thing will return true.</li>\n</ol>\n<pre><code>console.log(Boolean(\"\")); // false\r\nconsole.log(Boolean(\"   \\n\")); // true\r\nconsole.log(Boolean(undefined)); // false\r\nconsole.log(Boolean(null)); // true\r\nconsole.log(Boolean({})); // true\r\nconsole.log(Boolean([])); // true\n</code></pre>\n<p>| falsy     | truthy       |\r\n| --------- | ------------ |\r\n| “”        | “foo”        |\r\n| 0,-0      | 23           |\r\n| null      | {a:1}        |\r\n| NaN       | [1,3]        |\r\n| false     | true         |\r\n| undefined | function(){} |</p>\n<h3>Equality and Coercion</h3>\n<p>Usually, we say that in order to not deal with coercion we always use <code>===</code> everywhere and hence we don’t need to think about coercion ever. Is it really true or we are just being ignorant about it? Let’s see.</p>\n<ul>\n<li>We are all familiar with the template literal syntax from the es6 and we use it all over the place. Let’s consider an example to illustrate more</li>\n</ul>\n<pre><code>let numOfStudents = 15;\r\nconsole.log(`Total students are ${numOfStudents}`); // Total students are 15\r\nnumOfStudents = {};\r\nconsole.log(`Total students are ${numOfStudents}`); // Total students are [object Object]\n</code></pre>\n<ul>\n<li>In the code above also the template literal is being coerced to string type by doing the <code>ToString</code> operation and when we see that due to <code>numOfStudents</code> reassigned as <code>object</code> we see the log as <code>[object Object]</code></li>\n</ul>\n<pre><code>let numOfStudents = 15;\r\nlet newStudents = \"4\";\r\nlet newTotal = numOfStudents + newStudents;\r\n\r\nconsole.log(newTotal); // 154\n</code></pre>\n<ul>\n<li>The <code>+</code> operator whenever seeing any of the two elements as a string it prefers string concatenation.</li>\n<li>There are more such places where there is implicit coercion and sometimes we embrace that without even noticing that coercion is taking place and sometimes we make fun of that. However ideal response should be to learn about the language properly rather than thinking it of as some magic.</li>\n</ul>\n<p>Before going let’s look at the code snippet below to see some kind of corner case in javascript and try to find some conclusion base on the idea of abstract operation that we’ve read above.</p>\n<pre><code>console.log(Number(\"\")); // 0\r\nconsole.log(Number(\"  \\t\")); // 0\r\nconsole.log(Number(null)); // 0\r\nconsole.log(Number(undefined)); // NaN\r\nconsole.log(Number([])); // 0\r\nconsole.log(Number([1, 2, 3])); // NaN\r\nconsole.log(Number([null])); // 0\r\nconsole.log(Number([undefined])); // 0\r\nconsole.log(Number({})); // NaN\r\n\r\nconsole.log(String(-0)); // 0\r\nconsole.log(String(null)); // null\r\nconsole.log(String(undefined)); // undefined\r\nconsole.log(String([null])); // \"\"\r\nconsole.log(String([undefined])); // \"\"\r\n\r\nconsole.log(Boolean(new Boolean(false))); // true\r\n\r\nconsole.log(Number(true)); // 1\r\nconsole.log(Number(false)); // 0\r\n\r\nconsole.log(1 &#x3C; 2); // true\r\nconsole.log(2 &#x3C; 3); // true\r\nconsole.log(1 &#x3C; 2 &#x3C; 3); // true\r\n\r\nconsole.log(1 &#x3C; 2 &#x3C; 3); // true\r\nconsole.log(true &#x3C; 3); // true\r\nconsole.log(1 &#x3C; 3); // true\r\n\r\nconsole.log(3 > 2); // true\r\nconsole.log(2 > 1); // true\r\nconsole.log(3 > 2 > 1); // false\r\n\r\nconsole.log(3 > 2 > 1); // false\r\nconsole.log(true > 1); // false\r\nconsole.log(1 > 1); // false\n</code></pre>\n<p>By keeping in mind the corner cases shown below we will see how we can easily learn the difference between <code>==</code> and <code>===</code>.</p>\n<h3>Equality (<code>==</code> vs <code>===</code>)</h3>\n<p>The most common place where we notice coercion is when we use double equal <code>==</code> and hence due to that we have a notion to use <code>===</code> everywhere to <strong>avoid coercion</strong>.</p>\n<ul>\n<li>We have a notion that <code>==</code> checks value or we can call loose equality check whereas <code>===</code> check value as well as the type which is strict equality check</li>\n<li>However, this notion is not totally true. Let’s see how.</li>\n<li>We people have a feeling that implicit mechanism is kind of magical and we tend to equate magic as bad or evil. However, we can think about implicitness as an abstraction.</li>\n<li>Spec for the link: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison\">https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison</a></li>\n<li>When the types match the <code>===</code> and the <code>==</code> are the same</li>\n<li>For <code>===</code> if the types are different then it return false</li>\n<li>The basic difference then when we are using <code>==</code> and <code>===</code> is whether we allow coercion to happen or not</li>\n<li>It also denotes that both <code>==</code> and <code>===</code> check the type but one allows coercion while the other doesn’t</li>\n<li>In the case of two objects having the same value neither <code>==</code> nor the <code>===</code> will return true because they are two different objects at different memory locations and despite having the same type still they return false.</li>\n<li>In the case of <code>==</code> if it is null and undefined then they are equal</li>\n</ul>\n<pre><code>let a = null;\r\nlet b = undefined;\r\n\r\nconsole.log(a == b); // due to array stringifying\n</code></pre>\n<ul>\n<li><code>==</code> prefers a numeric comparison</li>\n<li><code>==</code> always compares two primitive values and if they don’t get a primitive value in either of the two then it does the toPrimitive() operation which first does valueOf() and then toString() to get the result</li>\n<li>We should try to make comparisons mostly by making the type the same whenever it is possible.</li>\n</ul>\n<p><strong>Corner Cases of <code>==</code></strong></p>\n<pre><code>let a = 14;\r\nlet b = [14];\r\n\r\nconsole.log(a == b); // due to array stringifying\r\n\r\nconsole.log([] == ![]); // true\r\n// however we never do such comparison in our real program only place we do in JS is while\r\n// checking a NaN value or something\r\n\r\n// Using Booleans we should not use double equals\r\nlet arr = [];\r\n\r\nconsole.log(arr == true); // false\r\nconsole.log(arr == false); // true\r\nconsole.log(arr === true); // false\n</code></pre>\n<h3>Summary</h3>\n<ul>\n<li>Avoid <code>==</code> with 0 or <code>“”</code> or even <code>“ \"</code></li>\n<li>Avoid using <code>==</code> with non-primitives</li>\n<li>Don’t use <code>==</code> to <code>true</code> and <code>false</code></li>\n<li><code>==</code> is not about comparisons with unknown types</li>\n<li>Always use <code>==</code> when you know the types and optionally if you need to have coercion</li>\n<li>When the types are the same then <code>==</code> is the same as <code>===</code></li>\n<li>If the types are different, the equivalent of one <code>==</code> would be two (or more) <code>===</code> (i.e, slower)</li>\n<li>If you don’t know about the types then to make it an obvious comparison to the reader that there are uncertainty we can use <code>===</code></li>\n<li>Making types known and obvious leads to better code. If types are known, <code>==</code> is best. Otherwise ,fall back to <code>===</code></li>\n</ul>\n<h3>Credits :</h3>\n<ul>\n<li>Deep JS Foundation: <a href=\"https://frontendmasters.com/courses/deep-javascript-v3/\">https://frontendmasters.com/courses/deep-javascript-v3/</a></li>\n</ul>\n<h3>Links and Resources for further reading</h3>\n<ol>\n<li>Specs for Language Types: <a href=\"https://262.ecma-international.org/11.0/#sec-ecmascript-language-types\">https://262.ecma-international.org/11.0/#sec-ecmascript-language-types</a></li>\n<li>Specs for Strict Equality Comparison: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison\">https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison</a></li>\n<li>ToPrimitive : <a href=\"https://262.ecma-international.org/11.0/#sec-toprimitive\">https://262.ecma-international.org/11.0/#sec-toprimitive</a></li>\n<li>Corner Cases in other languages: <a href=\"https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/\">https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/</a>.</li>\n<li>valueOf() : <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf</a></li>\n<li>isNaN : <a href=\"https://262.ecma-international.org/11.0/#sec-isnan-number\">https://262.ecma-international.org/11.0/#sec-isnan-number</a></li>\n<li>Number.isNaN : <a href=\"https://262.ecma-international.org/11.0/#sec-number.isnan\">https://262.ecma-international.org/11.0/#sec-number.isnan</a></li>\n<li>A great video showing some weird js behavior that we’ve read above: <a href=\"https://www.youtube.com/watch?v=et8xNAc2ic8\">https://www.youtube.com/watch?v=et8xNAc2ic8</a></li>\n<li>A website containing a lot of weird corner cases of javascript: <a href=\"https://wtfjs.com/\">https://wtfjs.com/</a></li>\n</ol>\n<blockquote>\n<p>If you have any suggestions for improvement please reach out to me at <a href=\"https://twitter.com/RafeeqSyedAmjad\">Twitter</a></p>\n</blockquote>\n"},{"id":"debouncing-and-throttling","title":"Debouncing and Throttling in JavaScript","description":"A brief explanation of debouncing and throttling in JavaScript","date":"2022-08-08","content":"<p>In Javascript, we have basically two ways to schedule things. One is <code>setTimeout</code> and the other is <code>setInterval</code>. Suppose you have a scenario where you have to build a Search Autocomplete Component where once the user starts typing you can show thenm some auto-complete result based on the query. Now that seems easy as you can just add a <code>keyup</code> listener to the input and you can start firing the request to you backend. Suppose your search component searches for images by querying image description and a user type the query <code>a man sitting on a bench alone while it's raining</code> now guesses what will happen. As for every keystroke, we are firing requests and the above query’s length is 48, which means for every average query a search will call around 30 API calls. That’s obviously not very efficient. Isn’t it? So how can we solve the above problem by keeping in mind user experience as well as not making so many API calls? The answer is using <code>debounce</code> or using <code>throttling</code>. Let’s understand both by taking some examples</p>\n<h2>Debouncing in JavaScript</h2>\n<p>It is a way to decide how often you want a certain function to be called. In debouncing we have a delay parameter. Now when we call our debounced function it fires on the first go but is executed after the delay. Suppose, we have an autocomplete search then what debounced function will do is as we keep typing some query it doesn’t fire any request, while once we stopped typing then after the delay time the request gets fired off. Hence when using search auto-complete suppose a user wanted to search for <code>laptop 4gb ram 256 ssd</code>. So when the user types <code>laptop</code> and then waits for the delay time then the first API call happens with <code>laptop</code>, and then it populates some auto complete result like <code>laptop i5</code>, or <code>laptop 4gb ram</code>. Then again it follows the same process once the user types some other follow-up query and hence we limit the number of API calls as well as give a good user experience too.</p>\n<p>Let’s implement a debounce function now. We should keep in mind that while writing our debounce function we will use the idea of closure to let our debouce function return another function which is debounced and has the delay time passed beforehand. The function signature and the usage is shown below.</p>\n<pre><code>// the function signature will look like this\r\nfunction debounce(fn,time) : () => {}\r\n\r\nconst callApi = () => {\r\n  console.log(\"api called\");\r\n}\r\n\r\nconst myDebouncedSearch = debounce(callApi,200);\r\n\r\n// now we can use our debouncedSearch function by adding it to some event listener or stuff like that\n</code></pre>\n<p>After looking at the code snippet you have got some idea what we will be going to do. So without wasting time let’s write our debounce function</p>\n<pre><code>function debounce(fn, time) {\r\n  let timeoutId = null;\r\n  return function (args) {\r\n    if (timeoutId) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n    timeoutId = setTimeout(() => {\r\n      fn(args);\r\n      timeoutId = null;\r\n    }, time);\r\n  };\r\n}\r\n\r\nconst callApi = (name) => {\r\n  console.log(name, \"called\");\r\n};\r\n\r\nconst myDebouncedSearch = debounce(callApi, 200);\r\n// now we can use our debouncedSearch function by adding it to some event listener or stuff like that\r\nmyDebouncedSearch(\"dog\");\r\nmyDebouncedSearch(\"cat\");\r\nmyDebouncedSearch(\"rat\");\r\nmyDebouncedSearch(\"mat\");\r\nmyDebouncedSearch(\"fat\");\r\nmyDebouncedSearch(\"bat\"); // bat called\n</code></pre>\n<p>Now let’s learn about the approach</p>\n<ol>\n<li>First of all we have to just delay the function call for the given time so we used <code>setTimeout</code> for doing the same.</li>\n<li>Now we have used the idea of closure to inject the delay time through our debounce function and then use it further by passing the arguments needed for the function call.</li>\n<li>Now as we know in debounce only the last function is get called and all the previous one are get cancelled.</li>\n<li>So keep a refrence of the function call we assigned our timer to some variable and then we check whether the variable is <code>null</code> or it is assigned some value. If there is some value for the timer varibble which is the <code>timerId</code> then we know some function is being executed and hence we clear that last function call by calling the <code>clearTimeout</code> and let the function call the last called function.</li>\n<li>Finally we also set the variable storing timeoutId to <code>null</code> to preserve the intial state.</li>\n</ol>\n<p>That’s all is for debouncing and you can clearly see how useful it is and there are so many usecase for it when we want to limit some function call.</p>\n<h3>Throttling</h3>\n<p>Throttling is also a similar concept which is used to limit function calls. However it has a slight difference, as in case of debounce only the last function gets called, in throttling we call the first function and unless the delay time has passed we execute the next called function. If there afe function calls before the delay time it gets ignored and doesn’t get called. Throttle is useful where some event get called very frequently. Suppose you want to track the user movement on your platoform and you’ve added a <code>mousemove</code> event on the view and fire some request based on the mouse move event. But you’ll notice that for tiny mouse movement the event gets called a lot of time. Hence in order to limit the API calls here we can throttle the API call based on some delay time. There are many such other case where you want to throttle the function call to limit certain things. Enough of words now let’s look at some code and implement throttle function.</p>\n<pre><code>// throttle function\r\nfunction throttle(fn, time) {\r\n  let timeoutId = null;\r\n  return function (args) {\r\n    if (timeoutId) {\r\n      console.log(\"cancelled call\", args); // added a log for testing\r\n      return;\r\n    }\r\n    timeoutId = setTimeout(() => {\r\n      fn(args);\r\n      timeoutId = null;\r\n    }, time);\r\n  };\r\n}\r\n\r\n// for testing\r\n\r\nconst callApi = (name) => {\r\n  console.log(name, \"called\");\r\n};\r\n\r\nconst myThrottle = throttle(callApi, 200);\r\n\r\nfunction simulateFiringEvents(num) {\r\n  let i = 0;\r\n  let interval = setInterval(() => {\r\n    if (i === num) {\r\n      clearInterval(interval);\r\n      return;\r\n    }\r\n    myThrottle(i);\r\n    i++;\r\n  }, 5);\r\n}\r\n\r\nsimulateFiringEvents(100);\n</code></pre>\n<p>Now let’s learn about the approach</p>\n<ol>\n<li>Here in throttle we check wheter there is timeoutId is not <code>null</code>. If it is not <code>null</code> then it means there is some function already being called and hence we just return from there without calling the function.</li>\n<li>Now in the setTimeout we assign the timeoutId to <code>null</code> once the function is executed and hence we are able to let new function get called, and the same process goes on limiting subsequent call during the delay time.</li>\n</ol>\n<p>This is all for throttling and you can really see how useful it is for various usecases. However there is more better implementation of debounce and throttle in libraries like <code>lodash</code> or <code>underscore</code> and they handle all the edge cases.</p>\n<p>You can look at the source code to get a more cleared idea : <a href=\"https://github.com/lodash/lodash/blob/master/debounce.js\">https://github.com/lodash/lodash/blob/master/debounce.js</a></p>\n<p>That’s all for today.</p>\n<p>If you find this useful please share it or have some suggestion for improvement please react out to me on <a href=\"https://twitter.com/MobashirFarhan\">Twitter</a>.</p>\n"},{"id":"intro-to-functional-programming","title":"Introduction to Functional Programming","description":"Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.","date":"2022-05-05","content":"<p>In computer science, functional programming is a programming paradigm more specifically a declarative paradigm where programs are constructed using functions and composing functions. In functional programming, functions are treated as values that can be passed to other functions as arguments. Languages support like Haskell, Clojure, Elm support functional patterns very well. Javascript, on the other hand, is not really a fully functional language however <code>functions</code> in Javascript are first-class citizens and hence we can use it to use functional programming in our code really well.</p>\n<p>Functional programming has one simple and main idea of having pure functions which basically means it only takes its input in gives output back irrespective of what having outside of the world.</p>\n<ol>\n<li>Pure functions don’t have any side effects and to know what is side-effects you can say them as the things which are done not as part of the function return value.</li>\n<li>Pure functions are deterministic.</li>\n</ol>\n<p><strong>Example of an impure function</strong></p>\n<pre><code>\r\nlet name = \"Mobashir\";\r\nfunction sayHello() {\r\n  console.log(`Hello ${name}`);\r\n}\r\n\r\nsayHello(); // Mobashir\r\nname = \"Farhan\";\r\nsayHello(); //  Farhan\n</code></pre>\n<p><strong>Example of a pure function</strong></p>\n<pre><code>function sayHello(name) {\r\n  return `Hello ${name}`;\r\n}\r\n\r\nconsole.log(sayHello(\"Mobashir\")); // Mobashir\r\nconsole.log(sayHello(\"Mobashir\")); // Mobashir\r\nconsole.log(sayHello(\"Farhan\")); // Farhan\n</code></pre>\n<p>In both examples, we can see the impure function gives unexpected results due to a change of name variable and hence it has some connection with the outside world, while the pure function just takes the input and gives the same output wherever we call it.</p>\n<p>When we are doing functional programming we mostly take care of the computational aspect of the program and not the side effects like making an API call or logging some data to the console or database transaction.</p>\n<p>So if we are writing a program in a functional pattern we basically remove all the side effects to the outside of the world and then the remaining part remains pure. This helps us to be a little bit more deterministic about the code and also helps us in unit testing.</p>\n<p><strong>Why Functional Programming?</strong></p>\n<ol>\n<li>Functional programs are more deterministic</li>\n<li>They are a more kind of self-documented</li>\n<li>They are easy to debug</li>\n<li>Of course, they will always be easy to unit test and help us in the removal of mocking the program and all the complicated stuff to test our code.</li>\n<li>Many folks have the notion that the functional paradigm is the best paradigm is not really the case as we know in computer science there is always a tradeoff and we will look at that as we go ahead.</li>\n<li>Functional programming can be good in a lot of cases like data transformation, or we want to really be certain for some calculation or stuff like that, it is then a good choice.</li>\n</ol>\n<p>We should not have our goal to learn functional programming and tend to look smart instead we should learn it in a deeper way which will help us to figure out how to write our code in a more efficient and self-documented way in which we test, debug and ship easily.</p>\n<h3>What should we keep in mind while doing functional programming</h3>\n<ol>\n<li>We should do everything with the help of functions.</li>\n<li>We thinking about writing our program instead of thinking about what my program will do we should think of what my program will take and what it will give back.</li>\n<li>Functional programming works well with strongly typed data and functions</li>\n<li>Example of imperative style</li>\n</ol>\n<pre><code>// imperative style\r\nlet name = \"John\";\r\nlet score = 5;\r\n\r\nconsole.log(`${name} scored ${score}`); // John scored 5\r\nscore = 10;\r\nconsole.log(`${name} scored ${score}`); // John scored 10\n</code></pre>\n<p>In the above example, we cannot directly tell what are the input here and what are the outputs and we have to see all the imperative commands to actually know the result. However, in the example below let have a look at a more functional approach</p>\n<pre><code>// functional way\r\nfunction nameAndScore(name, score) {\r\n  return `${name} score ${score}`;\r\n}\r\n\r\nconsole.log(nameAndScore(\"Naresh\", 10)); // Naresh scored 10\r\nconsole.log(nameAndScore(\"Ali\", 7)); //  Ali scored 7\n</code></pre>\n<p>In the example above we can easily predict the input as well as the output of the program due to these pure functions.</p>\n<h3>Recursion</h3>\n<p>Now we will look at the importance of recursion in functional programming and how it help us to stay out of using loop in our program and being more imperative</p>\n<p>In the recursive approach, we will be calling the function from within itself. Here instead of handling state, we will just keep in mind the input that is going in the function and the output going out of the function.</p>\n<blockquote>\n<p>Iteration doesn’t really go well with functional programming and hence while doing functional programming we should think more about the recursive approach</p>\n</blockquote>\n<p>Let’s compare a function with an iterative approach as well as a recursive approach</p>\n<p><strong>Iterative approach</strong></p>\n<pre><code>// iterative approach\r\nfunction sum(arrayOfNums) {\r\n  let sumTotal = 0;\r\n  for (let i = 0; i &#x3C; arrayOfNums.length; i++) {\r\n    sumTotal += arrayOfNums[i];\r\n  }\r\n  return sumTotal;\r\n}\r\n\r\nconsole.log(sum([1, 2, 3, 4, 5])); // 15\n</code></pre>\n<p><strong>Recursive approach</strong></p>\n<pre><code>// recursive approach\r\nfunction sum(arrayOfNums) {\r\n  if (arrayOfNums.length === 1) {\r\n    // base case\r\n    return arrayOfNums[0];\r\n  } else {\r\n    // recursive function\r\n    return arrayOfNums[0] + sum(arrayOfNums.slice(1));\r\n  }\r\n}\r\n\r\nconsole.log(sum([1, 2, 3, 4, 5])); // 15\n</code></pre>\n<p>While writing recursive functions we should keep two things in our mind:</p>\n<ol>\n<li>Base Case: In our code the if block is the base case</li>\n<li>Recursive Case: The else block is the recursive case</li>\n<li>Recursion doesn’t ensure the function is a pure function.</li>\n</ol>\n<p><strong>Let’s take another example of the recursive approach and iterative approach</strong></p>\n<p>Iterative Fibonacci Sum</p>\n<pre><code>// recursive approach\r\nfunction iterativeFibonacci(n) {\r\n  if (n === 0) {\r\n    return 0;\r\n  }\r\n  if (n === 1) {\r\n    return 1;\r\n  }\r\n  let previous = 0;\r\n  let current = 1;\r\n  for (let i = n; i > 1; i--) {\r\n    let next = previous + current;\r\n    previous = current;\r\n    current = next;\r\n  }\r\n  return current;\r\n}\r\n\r\nconsole.log(iterativeFibonacci(10)); // 55\n</code></pre>\n<p>Recursive fibonacci sum</p>\n<pre><code>// recursive approach\r\nfunction recursiveFibonacci(n) {\r\n  if (n === 0) {\r\n    return 0;\r\n  }\r\n  if (n === 1) {\r\n    return 1;\r\n  }\r\n  return recursiveFibonacci(n - 2) + recursiveFibonacci(n - 1);\r\n}\r\n\r\nconsole.log(recursiveFibonacci(10));\n</code></pre>\n<p><strong>Problems with recursion</strong></p>\n<ol>\n<li>Many times we do the same calculation over and over again and the solution to this is memoization.</li>\n<li>The second problem is the stack overflow when calling the recursive function with very large number like in Fibonacci and the solution to that is tail call recursion. It is a thing in js runtime that if we write our recursive function in a particular way it does optimization for us.</li>\n<li>When doing recursion we are playing with call stack and hence debugging it is a little bit complicated.</li>\n<li>Only safari supports tail call optimization properly. Chrome and V8 don’t.</li>\n</ol>\n<h3>Higher Order Function <code>map</code>,<code>filter</code>,<code>reduce</code></h3>\n<p>Javascript has a first-class function which means we can pass a function as the arguments to other functions.</p>\n<p>Higher order functions are the functions that take in other functions as input. We will use higher-order functions more while working with functional programming in javascript. They are also the alternative to loop</p>\n<p>All these <code>map</code>,<code>filer</code>,<code>reduce</code> are array methods and they work on the array.</p>\n<ol>\n<li>Filter filters something from an array base on some condition.</li>\n<li>Map takes an array and do some operation and then returns the operated array.</li>\n<li>Reduce take an array and reduce it to one single value or some accumulated value.</li>\n</ol>\n<p><strong>Let's learn more about these functions:</strong></p>\n<ol>\n<li>Map and filter don’t mutate the array and can be called a pure function but your callback doesn’t ensure to be a pure function and it can have impurities.</li>\n</ol>\n<h3>Filter</h3>\n<p>let us write our own basic filter function.</p>\n<pre><code>function myFilter(array, cb) {\r\n  let returnArr = [];\r\n  array.forEach((item) => {\r\n    if (cb(item)) {\r\n      returnArr.push(item);\r\n    }\r\n  });\r\n  return returnArr;\r\n}\r\n\r\nfunction isEven(item) {\r\n  if (item % 2 === 0) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isGreaterThan5(item) {\r\n  if (item > 5) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconsole.log(myFilter([1, 2, 3, 4, 5, 6], isEven)); // [2,4,6]\r\nconsole.log(myFilter([1, 2, 3, 4, 5, 6], isGreaterThan5)); // [6]\n</code></pre>\n<p>Appraoch : Here we have followed these steps while creating the filter function</p>\n<ul>\n<li>First we made a function that will take an array and a callback function as arguments</li>\n<li>Then we make an empty array and returned it. This helps our data to be immutable</li>\n<li>Then we start looping through the array and checked it the return value from calling our callback function taking every item of the array as the arguments return true or false. If the result is true we pushed them into oor return array else we did nothing.</li>\n<li>This way we have made our own filter function.</li>\n</ul>\n<h3>Map</h3>\n<p>Let us write our own mapping function similar to <code>Array.map()</code></p>\n<pre><code>function myMap(array, cb) {\r\n  let returnArr = [];\r\n  array.forEach((item) => {\r\n    returnArr.push(cb(item));\r\n  });\r\n  return returnArr;\r\n}\r\n\r\nlet myArray = [1, 2, 3, 4];\r\n\r\nfunction doubleItem(item) {\r\n  return item * 2;\r\n}\r\nconsole.log(myArray); // [1,2,3,4]\r\nconsole.log(myMap(myArray, doubleItem)); // [2,4,6,8]\r\nconsole.log(myArray); // [1,2,3,4]\n</code></pre>\n<p>Approach: We have followed the following steps while writing our own mapping function</p>\n<ul>\n<li>As we know map returns the same length array after doing some operation on the array and also doesn’t mutate the array.</li>\n<li>So the first step I have taken is to define our function which will take two arguments namely <code>array</code> and <code>callback function</code> .</li>\n<li>Then we declare an empty array and return the same array. This ensures immutability.</li>\n<li>Then we loop through every item of the array that will be passed as an argument and we keep pushing the return value of the callback function being called with the item to the return array.</li>\n</ul>\n<h3>Reduce</h3>\n<p>Let us write our own mapping function similar to <code>Array.reduce()</code></p>\n<pre><code>function myReduce(array, cb, initialValue) {\r\n  let accumulator = initialValue;\r\n  array.forEach((item) => {\r\n    accumulator = cb(accumulator, item);\r\n  });\r\n  return accumulator;\r\n}\r\n\r\nlet myArray = [1, 2, 3, 4, 5];\r\n\r\nlet sum = myReduce(myArray, (acc, item) => acc + item, 0);\r\nconsole.log(sum); // 15\r\nlet product = myReduce(myArray, (acc, item) => acc * item, 1);\r\nconsole.log(product); // 120\n</code></pre>\n<p>Approach : We have followed the following steps while writing our own reduced function</p>\n<ul>\n<li>First, as we know reduce combine our array and reduce it on the basis of the reducer function being passed.</li>\n<li>The first step we took is defining our function which will take an array, a callback function, and an initial value.</li>\n<li>Then we made a local variable inside and assigned it to the value being passed as initialValue to the value of the accumulator.</li>\n<li>Then we loop over the array and keep assigning the accumulator to the value that came back as the return after calling the callback function with arguments as the accumulator and the item from the array.</li>\n<li>Finally, we return the accumulator</li>\n</ul>\n<h3>Closure</h3>\n<p>Closure is one of the things which is very handy in functional programming. As we use higher order function it basically takes some input and returns output according to that. However, within the body of the function, we can also define another function and we can define it’s own value and variable inside it. And when we define inner function it has the access to the variable from the outer function. And when we return the inner function from the outer function an interesting thing happens which let us remember the value of the outer function if we call the inner function. This helps us to not pollute the global execution context. That’s a lot of words I think. Let’s learn the same through the code.</p>\n<p><strong>Question:</strong> Write a function which when called for the first three times returns “Hello World”and in the fourth call return “Call limit reached”.</p>\n<p><strong>Approach 1:</strong> Using a global variable</p>\n<pre><code>let functionCallCount = 1;\r\nfunction sayHelloTillThreeTimes() {\r\n  if (functionCallCount &#x3C;= 3) {\r\n    functionCallCount += 1;\r\n    return \"Hello World\";\r\n  } else {\r\n    return \"Call Limit Reached\";\r\n  }\r\n}\r\n\r\n// calling the function\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Call Limit Reached\n</code></pre>\n<p>In the above, we have made the program work using the global variable which is not a good practice and we are polluting the global environment. So what we should do?</p>\n<p><strong>Approach 2:</strong> Not using the global variable</p>\n<pre><code>// not using global variable\r\nfunction sayHelloThreeTimes() {\r\n  let functionCallCount = 0;\r\n  return function inner() {\r\n    functionCallCount += 1;\r\n    if (functionCallCount &#x3C;= 3) {\r\n      return \"Hello World\";\r\n    } else {\r\n      return \"Call Limit Reached\";\r\n    }\r\n  };\r\n}\r\n\r\nlet useSayHelloThreeTimes = sayHelloThreeTimes();\r\n\r\n// calling the function\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Call Limit Reached\n</code></pre>\n<ul>\n<li>In the above example, we make an outer function and then initialize a count variable name inside of it.</li>\n<li>Then we have returned a function from that outer function in which we are checking the count variable and returning the value according to it.</li>\n<li>Now when we use the function then we have the access to the count variable when we call our function elsewhere and we can say after 3rd call it started returning “Call Limit Reached”</li>\n<li>This is what we call closure in javascript because javascript is lexically scoped</li>\n</ul>\n<h3>Partial Application and Currying</h3>\n<p>Partial application is the notion of remembering some arguments of a function helping us to make reuse easily.</p>\n<p>Currying is basically making a multi-arguments function into a series of single-argument functions.</p>\n<p>Let’s look at some code to get a more clear understanding</p>\n<pre><code>// normal function\r\nfunction greet(greetWord, name) {\r\n  return `${greetWord} ${name}`;\r\n}\r\n\r\nlet greetInEnglish = greet(\"Hello\", \"John\");\r\nlet greetItalian = greet(\"Ciao\", \"John\");\r\n\r\nconsole.log(greetInEnglish); // Hello John\r\nconsole.log(greetItalian); // Ciao John\n</code></pre>\n<p>In the code above we have made a very basic greet function that takes in the greeting word and the name and then returns a greeting message. However, it looks very reusable but what if we want to greet 100 people in English . Then if you will look you will see we have to pass “Hello” as the greetword every time and that’s not a very good thing I think so. So how can we do better?</p>\n<p>Let’s look at another code example</p>\n<pre><code>// currying\r\nfunction greet(greetWord) {\r\n  return function (name) {\r\n    return `${greetWord} ${name}`;\r\n  };\r\n}\r\n\r\nlet greetInEnglish = greet(\"Hello\");\r\n// calling function\r\nconsole.log(greetInEnglish(\"John\")); // Hello John\r\nconsole.log(greetInEnglish(\"Sarah\")); // Hello Sarah\r\n\r\nlet greetItalian = greet(\"Ciao\");\r\n// calling the function\r\nconsole.log(greetItalian(\"John\")); // Ciao John\r\nconsole.log(greetItalian(\"Sarah\")); // Ciao Sarah\n</code></pre>\n<p>In the above example, we have made a curried greet function that takes in the greet word and returns us a function that further takes in the name and then returns the greet message.</p>\n<p>Since our curried function used the idea of closure and hence when we define our function greetEnglish it will always remember the greeting word as “Hello” and now if we want to greet a hundred people in English we can simply pass their names only. This is the idea behind currying and partial application</p>\n<h3>Function Composition</h3>\n<p>Since the idea behind functional programming is we have input coming and we have output and that output can be passed as input to other functions as well and this creates a kind of pipeline you can say.</p>\n<p>When we write our program in a functional way we look at how the data will be flowing inside our program through different functions.</p>\n<p>Here comes the idea of function composition where we take smaller functions and compose them together to get our desired output.</p>\n<p>Pipelining: Where we will make a function that takes any number of single argument functions and should return a single function representing their composition.</p>\n<pre><code>// // // ---- using recursion --- ///\r\n// helpers\r\nfunction length(arr) {\r\n  return arr.length;\r\n}\r\n\r\nfunction head(arr) {\r\n  return arr[0];\r\n}\r\n\r\nfunction tail(arr) {\r\n  return arr.slice(1);\r\n}\r\n\r\nfunction pipeline(...functions) {\r\n  if (length(functions) === 0) return (input) => input;\r\n  if (length(functions) === 1) (input) => head(functions)(input);\r\n  return function (input) {\r\n    return pipeline(...tail(functions))(head(functions)(input));\r\n  };\r\n}\r\n\r\n// helpers\r\nfunction makeLoweCase(str) {\r\n  return str.toLowerCase();\r\n}\r\n\r\nfunction slugify(str) {\r\n  return str.split(\"\").join(\"-\");\r\n}\r\n\r\nlet slugit = pipeline(makeLoweCase, slugify);\r\n\r\nconsole.log(slugit(\"HelloWorld\"));\n</code></pre>\n<p>In piping function together we need to keep in mind that the order matters</p>\n<p>Now let's write a pipe using reduce</p>\n<pre><code>function pipe(initialValue, ...functions) {\r\n  return functions.reduce((acc, item) => {\r\n    return item(acc);\r\n  }, initialValue);\r\n  return initialValue;\r\n}\r\n\r\nfunction makeLoweCase(str) {\r\n  return str.toLowerCase();\r\n}\r\n\r\nfunction slugify(str) {\r\n  return str.split(\"\").join(\"-\");\r\n}\r\n\r\nlet slugit = pipe(\"Hello\", makeLoweCase, slugify);\r\n\r\nconsole.log(slugit);\n</code></pre>\n<h3>Immutability</h3>\n<p>Immutability which means not mutating is a concept that really goes hand in hand in functional programming.</p>\n<p>How to keep avoid immutability while writing our javascript programs</p>\n<ul>\n<li>Don’t change in place instead replace</li>\n<li>Make a copy of our data and return that modified data instead of changing</li>\n<li>Use higher-order functions like map and filter to get free immutability</li>\n<li>One thing to also keep in mind is that copying data is not very efficient and if we have very big data then it can cause performance issues while copying it at different places.</li>\n<li>We can also use some libraries like ImmutableJs and Immer to ensure immutability while writing our javascript program.</li>\n</ul>\n<h3>Functional Javascript Utility</h3>\n<ol>\n<li>Lodash/FP: It is not the usual lodash , it has been implemented it in a functional programming way keeping in mind immutability and purity. Still, we need to look at the documentation before using any code to make sure all things go right.</li>\n<li>Ramda: It is one of the most popular ones and it is good for beginners</li>\n</ol>\n<p>Thanks to this</p>\n<p><a href=\"https://observablehq.com/collection/@anjana/functional-javascript-first-steps\">https://observablehq.com/collection/@anjana/functional-javascript-first-steps</a></p>\n<p><a href=\"https://frontendmasters.com/courses/functional-js-fundamentals/\">https://frontendmasters.com/courses/functional-js-fundamentals/</a></p>\n"},{"id":"how-searching-works","title":"How Search System Works Part I","description":"Searching happens so often and so quickly that we hardly get time to know what actually happens under the hood. When we type something on Google, an instant search takes place behind the scenes.","date":"2021-09-10","content":"<p>Searching happens so often and so quickly that we hardly get time to know what actually happens under the hood. When we type something on Google, an instant search takes place behind the scenes. It is really helpful to see a red underline when we write some words with wrong spelling in a word processing application. But have you wondered how the software instantly knows the same? That’s also an instant search behind the scenes. And besides all these, we have the ultimate achievement: the Web. The Web is so large that we can only guess its true size, and despite that web search engines can find relevant web pages in a fraction of seconds.</p>\n<blockquote>\n<p>How does the search engine find what we want so fast ?</p>\n</blockquote>\n<h1>Understanding the Search Problem.</h1>\n<p>To understand the search problem, at first, we need to know the terminologies and here it goes :</p>\n<ol>\n<li>Data collection: A collection of data.</li>\n<li>Record: Each item in data collection is called a record.</li>\n<li>Key: Every record is uniquely identified by a key.</li>\n</ol>\n<p>For instance, when you use a dictionary the word you’re looking up is key, and the definition of that word is the record and the dictionary is obviously our data collection in this case.</p>\n<p>The main objective of the search is to find the right record at a blazing fast speed because no one is gonna wait for minutes while searching for something on Google. So let’s dig deeper and learn how we achieve speed as well as accuracy while developing search engines.</p>\n<p><strong>The search mechanism needs these many steps to achieve accuracy and speed:</strong></p>\n<ol>\n<li>Organization of Data (Sorting)</li>\n<li>Searching</li>\n<li>Indexing</li>\n<li>Hashing</li>\n</ol>\n<p>Now, let's start to know each one in more detail.</p>\n<h2>Organizing the data</h2>\n<p>Well-organized data is a must for efficient search. When you visit a bookstore and if the books are organized alphabetically by the author names. It’s easy to know where to look for, like our dictionary example. If the bookstore has no such organization of books then it will be harder for us to know where to look for. So to solve this problem we may start from one end and keep looking till the end of the shelves until we find that particular book. This process can also be called a sequential search and is not efficient. Therefore, it is really important to keep our data in an organized form which in computer science terms is known as sorting of data. There are numerous ways to sorting and each one of them is useful in some or other use case. The most commonly used sorting algorithm is quick sort and merge sort, while there are many other sorting methods like selection, insertion, bubble sort, etc. Comparing the selection sort and quick sort, on a particular computer a selection sort of 1,000,000 records would take around 3 hours, while a quick sort would take only about 11 minutes. That’s really amazing.</p>\n<h2>A simple search method: Binary Search</h2>\n<p>When data is in order, the software can find a particular record easily. Binary search is a simple search method where we search some particular key by choosing between two alternatives. Each step in a binary search eliminates half of the records from consideration which means it scales very well. In a linear search doubling the size of data doubles the time needed for an average search while in a binary search doubling the data just adds one more step. A linear search on average will examine 500,000 records while searching in a data of 1,000,000 whereas a binary search will examine no more than 20 for the same data size.</p>\n<h2>Indexing and Why it is necessary?</h2>\n<p>To keep things simple, our examples to this point have used just record keys but in practice, the rest of the records has to be stored somewhere else, and this can cause problems. To see why we have to dig deeper to understand the choice software faces when allocating storage space for data, whether in main memory, on a hard drive, or anywhere else.</p>\n<p><strong>—Fixed-size storage allocation</strong>: Fixed-size allocation assigns each record the same amount of space and it is commonly used for data that always has the same size or has a small maximum size. For example Credit Card number of 16 digits or allocation for a customer name of a maximum of 20 letters. So if the name is less than 20 the space is wasted but since the allocated space is small that doesn’t bother much.</p>\n<p><strong>— Variable size storage allocation:</strong> Variable size allocation exactly fits the data. For example a collection of MP3 files we allocate variable memory for that. The longer the song, the larger the MP3 file. This is because a short pop song would be of 3–4 MB while a rock song might be as large as 20MB. We will never want to allocate 20 MB for each song as a fixed allocation as it will waste a lot of memory. Hence we allocate variable storage for these.</p>\n<p>Although from the above example we have seen variable allocation uses space efficiently, but for an efficient search method, fixed storage allocation is required. This is because storage locations are nothing but numerical <em>addresses.</em> Every byte in a digital storage — whether in computer’s main memory, hard disk, etc. can be precisely located by its <em>addresses.</em></p>\n<blockquote>\n<p>For a method like binary search it is essential to find the record quickly which can only be achieved when we have a fixed size records. Without fixed-size record , the only way to find a record in particular position is to count the records, which is just a linear search and it totally defeats the point of efficiency.</p>\n</blockquote>\n<blockquote>\n<p>Hence choosing between fixed memory allocation and variable memory allocation means choosing between <strong>efficient search</strong> and <strong>efficient storage.</strong></p>\n</blockquote>\n<p>To solve this problem a technique called indexing is used which gives us both, i.e., <strong>an efficient search</strong> as well as <strong>efficient storage.</strong> Indexing just separates the keys from the rest of the records, much as a library card catalog allows readers to search for books on cards before actually retrieving the books from the shelves. **<em>An index is nothing but a table of records keys and addresses.</em> **The address themselves are stored as binary with a fixed number of digits. The index of the data is stored in the main memory e.g. in Microsoft “32-bit” and “64-bit” it has 32 and 64 bit as the main memory and hence it helps you refer to the particular address to search efficiently using something like a binary search. The rest of the record data is stored in a variable size allocation. This eventually produces data that is efficient for storage as well as for searching. We can have multiple indexes for different search criteria, and because the main record is just referenced by an address, having multiple indexes doesn’t greatly affect the total storage. For example, we can have data collection of songs where we can create multiple indexes based on different parameters like an artist, name of song, singer, genre, etc. And this eventually offers efficient storage as well as efficient search too.</p>\n<p><em>In the next part, we’ll learn about</em> **<em>hashing</em> **<em>and how it works under the hood, we’ll also learn about</em> <strong><em>Web Search</em></strong> <em>and how Google and other</em> <strong><em>search engine rank</em></strong> <em>their result, how they use their index effectively and what possibilities are there in the future for the search problem.</em></p>\n<p><strong>I hope you’ve learned something good from here for sure. Thanks for the read.</strong></p>\n"}]},"__N_SSG":true}