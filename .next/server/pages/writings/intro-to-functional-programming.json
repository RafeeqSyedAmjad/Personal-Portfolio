{"pageProps":{"postData":{"id":"intro-to-functional-programming","contentHtml":"<p>In computer science, functional programming is a programming paradigm more specifically a declarative paradigm where programs are constructed using functions and composing functions. In functional programming, functions are treated as values that can be passed to other functions as arguments. Languages support like Haskell, Clojure, Elm support functional patterns very well. Javascript, on the other hand, is not really a fully functional language however <code>functions</code> in Javascript are first-class citizens and hence we can use it to use functional programming in our code really well.</p>\n<p>Functional programming has one simple and main idea of having pure functions which basically means it only takes its input in gives output back irrespective of what having outside of the world.</p>\n<ol>\n<li>Pure functions don’t have any side effects and to know what is side-effects you can say them as the things which are done not as part of the function return value.</li>\n<li>Pure functions are deterministic.</li>\n</ol>\n<p><strong>Example of an impure function</strong></p>\n<pre><code>\r\nlet name = \"Mobashir\";\r\nfunction sayHello() {\r\n  console.log(`Hello ${name}`);\r\n}\r\n\r\nsayHello(); // Mobashir\r\nname = \"Farhan\";\r\nsayHello(); //  Farhan\n</code></pre>\n<p><strong>Example of a pure function</strong></p>\n<pre><code>function sayHello(name) {\r\n  return `Hello ${name}`;\r\n}\r\n\r\nconsole.log(sayHello(\"Mobashir\")); // Mobashir\r\nconsole.log(sayHello(\"Mobashir\")); // Mobashir\r\nconsole.log(sayHello(\"Farhan\")); // Farhan\n</code></pre>\n<p>In both examples, we can see the impure function gives unexpected results due to a change of name variable and hence it has some connection with the outside world, while the pure function just takes the input and gives the same output wherever we call it.</p>\n<p>When we are doing functional programming we mostly take care of the computational aspect of the program and not the side effects like making an API call or logging some data to the console or database transaction.</p>\n<p>So if we are writing a program in a functional pattern we basically remove all the side effects to the outside of the world and then the remaining part remains pure. This helps us to be a little bit more deterministic about the code and also helps us in unit testing.</p>\n<p><strong>Why Functional Programming?</strong></p>\n<ol>\n<li>Functional programs are more deterministic</li>\n<li>They are a more kind of self-documented</li>\n<li>They are easy to debug</li>\n<li>Of course, they will always be easy to unit test and help us in the removal of mocking the program and all the complicated stuff to test our code.</li>\n<li>Many folks have the notion that the functional paradigm is the best paradigm is not really the case as we know in computer science there is always a tradeoff and we will look at that as we go ahead.</li>\n<li>Functional programming can be good in a lot of cases like data transformation, or we want to really be certain for some calculation or stuff like that, it is then a good choice.</li>\n</ol>\n<p>We should not have our goal to learn functional programming and tend to look smart instead we should learn it in a deeper way which will help us to figure out how to write our code in a more efficient and self-documented way in which we test, debug and ship easily.</p>\n<h3>What should we keep in mind while doing functional programming</h3>\n<ol>\n<li>We should do everything with the help of functions.</li>\n<li>We thinking about writing our program instead of thinking about what my program will do we should think of what my program will take and what it will give back.</li>\n<li>Functional programming works well with strongly typed data and functions</li>\n<li>Example of imperative style</li>\n</ol>\n<pre><code>// imperative style\r\nlet name = \"John\";\r\nlet score = 5;\r\n\r\nconsole.log(`${name} scored ${score}`); // John scored 5\r\nscore = 10;\r\nconsole.log(`${name} scored ${score}`); // John scored 10\n</code></pre>\n<p>In the above example, we cannot directly tell what are the input here and what are the outputs and we have to see all the imperative commands to actually know the result. However, in the example below let have a look at a more functional approach</p>\n<pre><code>// functional way\r\nfunction nameAndScore(name, score) {\r\n  return `${name} score ${score}`;\r\n}\r\n\r\nconsole.log(nameAndScore(\"Naresh\", 10)); // Naresh scored 10\r\nconsole.log(nameAndScore(\"Ali\", 7)); //  Ali scored 7\n</code></pre>\n<p>In the example above we can easily predict the input as well as the output of the program due to these pure functions.</p>\n<h3>Recursion</h3>\n<p>Now we will look at the importance of recursion in functional programming and how it help us to stay out of using loop in our program and being more imperative</p>\n<p>In the recursive approach, we will be calling the function from within itself. Here instead of handling state, we will just keep in mind the input that is going in the function and the output going out of the function.</p>\n<blockquote>\n<p>Iteration doesn’t really go well with functional programming and hence while doing functional programming we should think more about the recursive approach</p>\n</blockquote>\n<p>Let’s compare a function with an iterative approach as well as a recursive approach</p>\n<p><strong>Iterative approach</strong></p>\n<pre><code>// iterative approach\r\nfunction sum(arrayOfNums) {\r\n  let sumTotal = 0;\r\n  for (let i = 0; i &#x3C; arrayOfNums.length; i++) {\r\n    sumTotal += arrayOfNums[i];\r\n  }\r\n  return sumTotal;\r\n}\r\n\r\nconsole.log(sum([1, 2, 3, 4, 5])); // 15\n</code></pre>\n<p><strong>Recursive approach</strong></p>\n<pre><code>// recursive approach\r\nfunction sum(arrayOfNums) {\r\n  if (arrayOfNums.length === 1) {\r\n    // base case\r\n    return arrayOfNums[0];\r\n  } else {\r\n    // recursive function\r\n    return arrayOfNums[0] + sum(arrayOfNums.slice(1));\r\n  }\r\n}\r\n\r\nconsole.log(sum([1, 2, 3, 4, 5])); // 15\n</code></pre>\n<p>While writing recursive functions we should keep two things in our mind:</p>\n<ol>\n<li>Base Case: In our code the if block is the base case</li>\n<li>Recursive Case: The else block is the recursive case</li>\n<li>Recursion doesn’t ensure the function is a pure function.</li>\n</ol>\n<p><strong>Let’s take another example of the recursive approach and iterative approach</strong></p>\n<p>Iterative Fibonacci Sum</p>\n<pre><code>// recursive approach\r\nfunction iterativeFibonacci(n) {\r\n  if (n === 0) {\r\n    return 0;\r\n  }\r\n  if (n === 1) {\r\n    return 1;\r\n  }\r\n  let previous = 0;\r\n  let current = 1;\r\n  for (let i = n; i > 1; i--) {\r\n    let next = previous + current;\r\n    previous = current;\r\n    current = next;\r\n  }\r\n  return current;\r\n}\r\n\r\nconsole.log(iterativeFibonacci(10)); // 55\n</code></pre>\n<p>Recursive fibonacci sum</p>\n<pre><code>// recursive approach\r\nfunction recursiveFibonacci(n) {\r\n  if (n === 0) {\r\n    return 0;\r\n  }\r\n  if (n === 1) {\r\n    return 1;\r\n  }\r\n  return recursiveFibonacci(n - 2) + recursiveFibonacci(n - 1);\r\n}\r\n\r\nconsole.log(recursiveFibonacci(10));\n</code></pre>\n<p><strong>Problems with recursion</strong></p>\n<ol>\n<li>Many times we do the same calculation over and over again and the solution to this is memoization.</li>\n<li>The second problem is the stack overflow when calling the recursive function with very large number like in Fibonacci and the solution to that is tail call recursion. It is a thing in js runtime that if we write our recursive function in a particular way it does optimization for us.</li>\n<li>When doing recursion we are playing with call stack and hence debugging it is a little bit complicated.</li>\n<li>Only safari supports tail call optimization properly. Chrome and V8 don’t.</li>\n</ol>\n<h3>Higher Order Function <code>map</code>,<code>filter</code>,<code>reduce</code></h3>\n<p>Javascript has a first-class function which means we can pass a function as the arguments to other functions.</p>\n<p>Higher order functions are the functions that take in other functions as input. We will use higher-order functions more while working with functional programming in javascript. They are also the alternative to loop</p>\n<p>All these <code>map</code>,<code>filer</code>,<code>reduce</code> are array methods and they work on the array.</p>\n<ol>\n<li>Filter filters something from an array base on some condition.</li>\n<li>Map takes an array and do some operation and then returns the operated array.</li>\n<li>Reduce take an array and reduce it to one single value or some accumulated value.</li>\n</ol>\n<p><strong>Let's learn more about these functions:</strong></p>\n<ol>\n<li>Map and filter don’t mutate the array and can be called a pure function but your callback doesn’t ensure to be a pure function and it can have impurities.</li>\n</ol>\n<h3>Filter</h3>\n<p>let us write our own basic filter function.</p>\n<pre><code>function myFilter(array, cb) {\r\n  let returnArr = [];\r\n  array.forEach((item) => {\r\n    if (cb(item)) {\r\n      returnArr.push(item);\r\n    }\r\n  });\r\n  return returnArr;\r\n}\r\n\r\nfunction isEven(item) {\r\n  if (item % 2 === 0) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction isGreaterThan5(item) {\r\n  if (item > 5) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconsole.log(myFilter([1, 2, 3, 4, 5, 6], isEven)); // [2,4,6]\r\nconsole.log(myFilter([1, 2, 3, 4, 5, 6], isGreaterThan5)); // [6]\n</code></pre>\n<p>Appraoch : Here we have followed these steps while creating the filter function</p>\n<ul>\n<li>First we made a function that will take an array and a callback function as arguments</li>\n<li>Then we make an empty array and returned it. This helps our data to be immutable</li>\n<li>Then we start looping through the array and checked it the return value from calling our callback function taking every item of the array as the arguments return true or false. If the result is true we pushed them into oor return array else we did nothing.</li>\n<li>This way we have made our own filter function.</li>\n</ul>\n<h3>Map</h3>\n<p>Let us write our own mapping function similar to <code>Array.map()</code></p>\n<pre><code>function myMap(array, cb) {\r\n  let returnArr = [];\r\n  array.forEach((item) => {\r\n    returnArr.push(cb(item));\r\n  });\r\n  return returnArr;\r\n}\r\n\r\nlet myArray = [1, 2, 3, 4];\r\n\r\nfunction doubleItem(item) {\r\n  return item * 2;\r\n}\r\nconsole.log(myArray); // [1,2,3,4]\r\nconsole.log(myMap(myArray, doubleItem)); // [2,4,6,8]\r\nconsole.log(myArray); // [1,2,3,4]\n</code></pre>\n<p>Approach: We have followed the following steps while writing our own mapping function</p>\n<ul>\n<li>As we know map returns the same length array after doing some operation on the array and also doesn’t mutate the array.</li>\n<li>So the first step I have taken is to define our function which will take two arguments namely <code>array</code> and <code>callback function</code> .</li>\n<li>Then we declare an empty array and return the same array. This ensures immutability.</li>\n<li>Then we loop through every item of the array that will be passed as an argument and we keep pushing the return value of the callback function being called with the item to the return array.</li>\n</ul>\n<h3>Reduce</h3>\n<p>Let us write our own mapping function similar to <code>Array.reduce()</code></p>\n<pre><code>function myReduce(array, cb, initialValue) {\r\n  let accumulator = initialValue;\r\n  array.forEach((item) => {\r\n    accumulator = cb(accumulator, item);\r\n  });\r\n  return accumulator;\r\n}\r\n\r\nlet myArray = [1, 2, 3, 4, 5];\r\n\r\nlet sum = myReduce(myArray, (acc, item) => acc + item, 0);\r\nconsole.log(sum); // 15\r\nlet product = myReduce(myArray, (acc, item) => acc * item, 1);\r\nconsole.log(product); // 120\n</code></pre>\n<p>Approach : We have followed the following steps while writing our own reduced function</p>\n<ul>\n<li>First, as we know reduce combine our array and reduce it on the basis of the reducer function being passed.</li>\n<li>The first step we took is defining our function which will take an array, a callback function, and an initial value.</li>\n<li>Then we made a local variable inside and assigned it to the value being passed as initialValue to the value of the accumulator.</li>\n<li>Then we loop over the array and keep assigning the accumulator to the value that came back as the return after calling the callback function with arguments as the accumulator and the item from the array.</li>\n<li>Finally, we return the accumulator</li>\n</ul>\n<h3>Closure</h3>\n<p>Closure is one of the things which is very handy in functional programming. As we use higher order function it basically takes some input and returns output according to that. However, within the body of the function, we can also define another function and we can define it’s own value and variable inside it. And when we define inner function it has the access to the variable from the outer function. And when we return the inner function from the outer function an interesting thing happens which let us remember the value of the outer function if we call the inner function. This helps us to not pollute the global execution context. That’s a lot of words I think. Let’s learn the same through the code.</p>\n<p><strong>Question:</strong> Write a function which when called for the first three times returns “Hello World”and in the fourth call return “Call limit reached”.</p>\n<p><strong>Approach 1:</strong> Using a global variable</p>\n<pre><code>let functionCallCount = 1;\r\nfunction sayHelloTillThreeTimes() {\r\n  if (functionCallCount &#x3C;= 3) {\r\n    functionCallCount += 1;\r\n    return \"Hello World\";\r\n  } else {\r\n    return \"Call Limit Reached\";\r\n  }\r\n}\r\n\r\n// calling the function\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Hello World\r\nconsole.log(sayHelloTillThreeTimes()); // Call Limit Reached\n</code></pre>\n<p>In the above, we have made the program work using the global variable which is not a good practice and we are polluting the global environment. So what we should do?</p>\n<p><strong>Approach 2:</strong> Not using the global variable</p>\n<pre><code>// not using global variable\r\nfunction sayHelloThreeTimes() {\r\n  let functionCallCount = 0;\r\n  return function inner() {\r\n    functionCallCount += 1;\r\n    if (functionCallCount &#x3C;= 3) {\r\n      return \"Hello World\";\r\n    } else {\r\n      return \"Call Limit Reached\";\r\n    }\r\n  };\r\n}\r\n\r\nlet useSayHelloThreeTimes = sayHelloThreeTimes();\r\n\r\n// calling the function\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Hello World\r\nconsole.log(useSayHelloThreeTimes()); // Call Limit Reached\n</code></pre>\n<ul>\n<li>In the above example, we make an outer function and then initialize a count variable name inside of it.</li>\n<li>Then we have returned a function from that outer function in which we are checking the count variable and returning the value according to it.</li>\n<li>Now when we use the function then we have the access to the count variable when we call our function elsewhere and we can say after 3rd call it started returning “Call Limit Reached”</li>\n<li>This is what we call closure in javascript because javascript is lexically scoped</li>\n</ul>\n<h3>Partial Application and Currying</h3>\n<p>Partial application is the notion of remembering some arguments of a function helping us to make reuse easily.</p>\n<p>Currying is basically making a multi-arguments function into a series of single-argument functions.</p>\n<p>Let’s look at some code to get a more clear understanding</p>\n<pre><code>// normal function\r\nfunction greet(greetWord, name) {\r\n  return `${greetWord} ${name}`;\r\n}\r\n\r\nlet greetInEnglish = greet(\"Hello\", \"John\");\r\nlet greetItalian = greet(\"Ciao\", \"John\");\r\n\r\nconsole.log(greetInEnglish); // Hello John\r\nconsole.log(greetItalian); // Ciao John\n</code></pre>\n<p>In the code above we have made a very basic greet function that takes in the greeting word and the name and then returns a greeting message. However, it looks very reusable but what if we want to greet 100 people in English . Then if you will look you will see we have to pass “Hello” as the greetword every time and that’s not a very good thing I think so. So how can we do better?</p>\n<p>Let’s look at another code example</p>\n<pre><code>// currying\r\nfunction greet(greetWord) {\r\n  return function (name) {\r\n    return `${greetWord} ${name}`;\r\n  };\r\n}\r\n\r\nlet greetInEnglish = greet(\"Hello\");\r\n// calling function\r\nconsole.log(greetInEnglish(\"John\")); // Hello John\r\nconsole.log(greetInEnglish(\"Sarah\")); // Hello Sarah\r\n\r\nlet greetItalian = greet(\"Ciao\");\r\n// calling the function\r\nconsole.log(greetItalian(\"John\")); // Ciao John\r\nconsole.log(greetItalian(\"Sarah\")); // Ciao Sarah\n</code></pre>\n<p>In the above example, we have made a curried greet function that takes in the greet word and returns us a function that further takes in the name and then returns the greet message.</p>\n<p>Since our curried function used the idea of closure and hence when we define our function greetEnglish it will always remember the greeting word as “Hello” and now if we want to greet a hundred people in English we can simply pass their names only. This is the idea behind currying and partial application</p>\n<h3>Function Composition</h3>\n<p>Since the idea behind functional programming is we have input coming and we have output and that output can be passed as input to other functions as well and this creates a kind of pipeline you can say.</p>\n<p>When we write our program in a functional way we look at how the data will be flowing inside our program through different functions.</p>\n<p>Here comes the idea of function composition where we take smaller functions and compose them together to get our desired output.</p>\n<p>Pipelining: Where we will make a function that takes any number of single argument functions and should return a single function representing their composition.</p>\n<pre><code>// // // ---- using recursion --- ///\r\n// helpers\r\nfunction length(arr) {\r\n  return arr.length;\r\n}\r\n\r\nfunction head(arr) {\r\n  return arr[0];\r\n}\r\n\r\nfunction tail(arr) {\r\n  return arr.slice(1);\r\n}\r\n\r\nfunction pipeline(...functions) {\r\n  if (length(functions) === 0) return (input) => input;\r\n  if (length(functions) === 1) (input) => head(functions)(input);\r\n  return function (input) {\r\n    return pipeline(...tail(functions))(head(functions)(input));\r\n  };\r\n}\r\n\r\n// helpers\r\nfunction makeLoweCase(str) {\r\n  return str.toLowerCase();\r\n}\r\n\r\nfunction slugify(str) {\r\n  return str.split(\"\").join(\"-\");\r\n}\r\n\r\nlet slugit = pipeline(makeLoweCase, slugify);\r\n\r\nconsole.log(slugit(\"HelloWorld\"));\n</code></pre>\n<p>In piping function together we need to keep in mind that the order matters</p>\n<p>Now let's write a pipe using reduce</p>\n<pre><code>function pipe(initialValue, ...functions) {\r\n  return functions.reduce((acc, item) => {\r\n    return item(acc);\r\n  }, initialValue);\r\n  return initialValue;\r\n}\r\n\r\nfunction makeLoweCase(str) {\r\n  return str.toLowerCase();\r\n}\r\n\r\nfunction slugify(str) {\r\n  return str.split(\"\").join(\"-\");\r\n}\r\n\r\nlet slugit = pipe(\"Hello\", makeLoweCase, slugify);\r\n\r\nconsole.log(slugit);\n</code></pre>\n<h3>Immutability</h3>\n<p>Immutability which means not mutating is a concept that really goes hand in hand in functional programming.</p>\n<p>How to keep avoid immutability while writing our javascript programs</p>\n<ul>\n<li>Don’t change in place instead replace</li>\n<li>Make a copy of our data and return that modified data instead of changing</li>\n<li>Use higher-order functions like map and filter to get free immutability</li>\n<li>One thing to also keep in mind is that copying data is not very efficient and if we have very big data then it can cause performance issues while copying it at different places.</li>\n<li>We can also use some libraries like ImmutableJs and Immer to ensure immutability while writing our javascript program.</li>\n</ul>\n<h3>Functional Javascript Utility</h3>\n<ol>\n<li>Lodash/FP: It is not the usual lodash , it has been implemented it in a functional programming way keeping in mind immutability and purity. Still, we need to look at the documentation before using any code to make sure all things go right.</li>\n<li>Ramda: It is one of the most popular ones and it is good for beginners</li>\n</ol>\n<p>Thanks to this</p>\n<p><a href=\"https://observablehq.com/collection/@anjana/functional-javascript-first-steps\">https://observablehq.com/collection/@anjana/functional-javascript-first-steps</a></p>\n<p><a href=\"https://frontendmasters.com/courses/functional-js-fundamentals/\">https://frontendmasters.com/courses/functional-js-fundamentals/</a></p>\n","title":"Introduction to Functional Programming","description":"Functional programming is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.","date":"2022-05-05"}},"__N_SSG":true}