{"pageProps":{"postData":{"id":"type-and-coercion-js","contentHtml":"<p>Most of you are familiar with the saying everyone quotes, which is “Everything in Javascript are Objects”. What if I tell you that’s not entirely true? In this blog, we will be taking a deep dive into types in Javascript. People try to stay away from types, especially in dynamically typed language but sometimes not knowing about types can cause some real bugs in your code. We often experience some weird behavior from our program as shown below.</p>\n<pre><code>true + true; // 2\r\n[] + ![]; // false\n</code></pre>\n<p>We see this kind of joke all around the internet and people say how poorly javascript is designed and all those stuff. But does that really make sense? The reason for making fun of that is basically we don’t know enough about javascript behavior and we see them as some magic or black box. What our response should be as a developer is to know our tools effectively and know the corner cases of them and henceforth avoid them while writing our code. There are corner cases in every big system and they can’t be avoided at all. The reason we don’t know about all these corner cases is that we hardly know what is actually being done by the javascript and rather we make some assumptions. If you want to look at corner cases of some other programming language visit here <a href=\"https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/\">https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/</a>.</p>\n<h3>Note</h3>\n<p>There will be a lot of new and weird things you will notice throughout the blog and it is sure that you will not get all the concepts by reading it once. What I will suggest is to learn slowly and try to look at all the code snippets shared below. Also, check all the links for the specs to get a clearer insight.</p>\n<p>Let’s get back to the quote</p>\n<p>However in the spec we can clearly see Javascript has types also called as primitive types</p>\n<p>Link: <a href=\"https://262.ecma-international.org/9.0/#sec-ecmascript-language-types\">https://262.ecma-international.org/9.0/#sec-ecmascript-language-types</a></p>\n<h3>Let’s dig into the primitive types</h3>\n<p>The Spec defines the following primitive types as follows</p>\n<ol>\n<li><code>undefined</code>: it has only one value that is undefined and any variable that has not been assigned a value has the value <code>undefined</code></li>\n<li><code>null</code>: it has only one value that is null and it represents the intentional absence of any object value</li>\n<li><code>boolean</code>: The boolean type represents a bool value that is either true of false</li>\n<li><code>string</code>: The string type is the set of all ordered sequences of zero or more 16-bit unsigned <a href=\"https://262.ecma-international.org/11.0/#integer\">integer</a> values (“elements”) up to a maximum length of 2 raise to the power 53 - 1 elements.</li>\n<li><code>number</code>: a set of all possible Number values including the special “Not-a-Number” (NaN) value, positive infinity, and negative infinity. And number value is a primitive value corresponding to a double-precision 64-bit binary format <a href=\"https://262.ecma-international.org/11.0/#sec-bibliography\">IEEE 754-2019</a> value</li>\n<li><code>object</code>: An Object is logically a collection of properties. Each property is either a data property or an accessor property like dot notation and so on.</li>\n<li><code>bigInt</code>: a set of all possible BigInt values that is a primitive value corresponding to an arbitrary-precision <a href=\"https://262.ecma-international.org/11.0/#integer\">integer</a> value</li>\n<li><code>symbol</code>: The Symbol type is the set of all non-String values that may be used as the key of an Object property. It is less used in normal development and is usually used in frameworks and library</li>\n</ol>\n<p>That’s a lot of academic kind of stuff up there so let’s see some code to know the types of variables using the <code>typeof</code> operator.</p>\n<pre><code>let v;\r\nconsole.log(typeof v); // undefined\r\nv = \"1\";\r\nconsole.log(typeof v); // string\r\nv = 2;\r\nconsole.log(typeof v); // number\r\nv = true;\r\nconsole.log(typeof v); // boolean\r\nv = {};\r\nconsole.log(typeof v); // object\r\nv = Symbol();\r\nconsole.log(typeof v); // symbol\r\nv = [1, 2, 3, 4];\r\nconsole.log(typeof v); // object\r\nv = () => \"hello\";\r\nconsole.log(typeof v); // function\r\nv = null;\r\nconsole.log(typeof v); // object\r\nv = 16n;\r\nconsole.log(typeof v); // bigint\r\n// corner case\r\nv = null;\r\nconsole.log(typeof null); // object\n</code></pre>\n<h2>Kinds of Emptiness</h2>\n<p>Let’s see about the kind of emptiness javascript offers:</p>\n<ul>\n<li>undeclared: a variable that has never been created in any scope</li>\n</ul>\n<pre><code>console.log(typeof m); // undefined\r\n// here in this case m doesn't even exist and still we get undefined becuase of javascript\r\n// pretend as if you can declare the variable after and is currently undeclared\n</code></pre>\n<ul>\n<li>undefined : there is a variable and at the moment it has no value</li>\n</ul>\n<pre><code>let v;\r\nconsole.log(typeof v); // undefined\n</code></pre>\n<ul>\n<li>uninitialized: for block scope variables they are not initialized or set to undefined and you cannot allow touching (tdz) and hence are in an uninitialized position. Learn more : <a href=\"https://www.freecodecamp.org/news/javascript-temporal-dead-zone-and-hoisting-explained/\">https://www.freecodecamp.org/news/javascript-temporal-dead-zone-and-hoisting-explained/</a></li>\n</ul>\n<h3>Some Special Value</h3>\n<h3>NaN (<code>not a number</code>)</h3>\n<ul>\n<li>NaN is called as <code>not a number</code> but if talking more specifically we can say it tells us about not a valid number according to IEEE 764: https://en.wikipedia.org/wiki/IEEE_754</li>\n<li>Here in the below example, we are doing a subtract operation with a string and a number which results in <code>NaN</code> and one most important property of <code>NaN</code> is that they are not equal to itself which is kind of weird but that’s how it is.</li>\n<li>Here in the example we also see that the <code>typeof NaN</code> returns a number. Hence we can conclude that <code>NaN</code> is a type of number but an invalid number.</li>\n</ul>\n<pre><code>// IEEE 764 : https://en.wikipedia.org/wiki/IEEE_754\r\nlet totalApples = 10;\r\nlet applesDistributed = \"five\";\r\nlet remainingApple = totalApples - applesDistributed;\r\n\r\nconsole.log(remainingApple); // NaN\r\nconsole.log(remainingApple === remainingApple); // false\r\nconsole.log(typeof remainingApple); // number\n</code></pre>\n<ul>\n<li>To check whether a value is <code>NaN</code> we have two functions, one is called <code>isNaN()</code> and the other is <code>Number.isNan()</code>. Let’s see what we get using <code>isNaN()</code></li>\n</ul>\n<pre><code>let greet = \"Hello world\";\r\n\r\n// using isNan\r\nconsole.log(typeof greet); // string\r\nconsole.log(isNaN(greet)); // true\n</code></pre>\n<ul>\n<li>In the above example, we can see that typeof greet is string however in the next line when we use isNaN on it returns true as if the greet is a <code>NaN</code> value. That’s weird. Isn’t it?</li>\n<li>Let’s see why it happens to link to the spec: <a href=\"https://262.ecma-international.org/11.0/#sec-isnan-number\">https://262.ecma-international.org/11.0/#sec-isnan-number</a> . As we can see that in spec it tells us that it first performs an abstract operation which we will learn about in a bit called ToNumber and then whatever value is returned is checked whether it is not equal to itself or not. If it is not equal to itself then we can conclude that the number is <code>NaN</code>. Let’s see it in action by writing our own isNaN()</li>\n</ul>\n<pre><code>function myIsNaN(num) {\r\n  if (typeof num !== \"number\") {\r\n    num = Number(num);\r\n    console.log(num);\r\n    return num !== num;\r\n  }\r\n}\r\n\r\nlet greet = \"Hello world\";\r\n\r\n// using isNan\r\nconsole.log(typeof greet); // string\r\nconsole.log(isNaN(greet)); // true\r\n\r\n// using myIsNaN\r\nconsole.log(myIsNaN(greet)); // true\n</code></pre>\n<ul>\n<li>You can clearly see why it treat string as <code>NaN</code> due to the abstract ToNumber operation.</li>\n<li>In order to fix this we get another utility function in Javascript called as <code>Number.isNaN</code> let's use it to learn its behavior</li>\n</ul>\n<pre><code>// IEEE 764 : https://en.wikipedia.org/wiki/IEEE_754\r\nlet totalApples = 10;\r\nlet applesDistributed = \"five\";\r\nlet remainingApple = totalApples - applesDistributed;\r\n\r\nconsole.log(remainingApple); // NaN\r\nconsole.log(remainingApple === remainingApple); // false\r\nconsole.log(typeof remainingApple); // number\r\n\r\n// using Number.isNaN()\r\nconsole.log(Number.isNaN(applesDistributed)); // false\r\nconsole.log(Number.isNaN(remainingApple)); // true\n</code></pre>\n<ul>\n<li>Here we see that as it is written in the specs that <a href=\"https://262.ecma-international.org/11.0/#sec-number.isnan\">https://262.ecma-international.org/11.0/#sec-number.isnan</a> and it shows that it doesn’t coerce the thing which is not a number type and directly return false.</li>\n</ul>\n<h3>Negative Zero <code>-0</code></h3>\n<p>We also have another special value which is <code>-0</code> and it also has some weird corner cases. Let’s see them through code</p>\n<pre><code>let trendRate = -0;\r\n\r\nconsole.log(trendRate === -0); // true\r\nconsole.log(trendRate.toString()); // 0\r\nconsole.log(trendRate === 0); // true\r\nconsole.log(trendRate &#x3C; 0); // false\r\nconsole.log(trendRate > 0); // false\r\n\r\n// to check negative zero we can use Object.is()\r\nconsole.log(Object.is(trendRate, -0)); // true\r\nconsole.log(Object.is(trendRate, 0)); // false\r\n\r\n// using Math.sign()\r\nconsole.log(Math.sign(-0)); // -0\r\nconsole.log(Math.sign(0)); // 0\r\nconsole.log(Math.sign(-3)); // -1\r\nconsole.log(Math.sign(3)); // 1\n</code></pre>\n<p>Here in the above example, we can see how weird it behaves while working with <code>-0</code> and how to handle that corner case.</p>\n<p>We also see that <code>Math.sign()</code> also return weird result in case of <code>0</code> and <code>-0</code> .</p>\n<h2>Abstract operation</h2>\n<p>The operations fundamentally perform the task of type coercion. They are not a specific type of function or something like that but they are a conceptual thing that let us understand coercion thing. Link for the specs here: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-operations\">https://262.ecma-international.org/11.0/#sec-abstract-operations</a> . There is a bunch of abstract operation that is performed on certain cases but we will look at a few that are more important to know in our day-to-day programming. We will use typecasting to demonstrate the abstract operation</p>\n<ol>\n<li><strong>ToNumber(value)</strong>: This operation converts the argument value to the type of number according to this table <a href=\"https://262.ecma-international.org/11.0/#table-11\">https://262.ecma-international.org/11.0/#table-11</a></li>\n</ol>\n<pre><code>// here we are using the build-in object to do the typecast\r\nconsole.log(Number(\"\")); // 0\r\nconsole.log(Number(\"0\")); // 0\r\nconsole.log(Number(\"-0\")); // -0\r\nconsole.log(Number(\"009\")); // 9\r\nconsole.log(Number(\"3.14\")); // 3.14\r\nconsole.log(Number(\"0.\")); // 0\r\nconsole.log(Number(\".0\")); // 0\r\nconsole.log(Number(\".\")); // NaN\r\nconsole.log(Number(\"0xaf\")); // 175\r\nconsole.log(Number(false)); // 0\r\nconsole.log(Number(true)); // 1\r\nconsole.log(Number(null)); // 0\r\nconsole.log(Number(undefined)); // NaN\r\nconsole.log(Number([\"\"])); // 0\r\nconsole.log(Number({})); // NaN\r\nconsole.log(Number([1, 2])); // NaN\r\nconsole.log(Number({ a: \"hello\" })); // NaN\n</code></pre>\n<ol>\n<li><strong>ToPrimitve(value, hint)</strong>: This operation is performed to covert any not primitive value to a primitive value and does it in two steps. First, it checks valueOf(), and then it converts it to ToString() to get the desired result. Link for further reading <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf</a></li>\n<li>ToString(value): This operation converts the argument value to the type of number according to this table <a href=\"https://262.ecma-international.org/11.0/#table-12\">https://262.ecma-international.org/11.0/#table-12</a>. Below represents some corner cases that create some exceptions when we will look into the equality and coercion section of the blog.</li>\n</ol>\n<pre><code>let c = -0;\r\nlet arr = [1, 2, 3, 4];\r\nlet arr1 = [null, undefined, true, 1, \"1\"];\r\nlet obj = { apple: \"red\" };\r\nconsole.log(arr.toString()); // \"1,2,3,4\"\r\nconsole.log(c.toString()); // \"0\"\r\nconsole.log(arr1.toString()); // \",,true,1,1\" | undefined and null are ignored\r\nconsole.log(obj.toString()); // [object Object]\n</code></pre>\n<ol>\n<li>ToBoolean(value): This operation covert any value to boolean type and it basically just does a lookup to the table given below and if any of the value does fall in the falsy side it returns false and every other thing will return true.</li>\n</ol>\n<pre><code>console.log(Boolean(\"\")); // false\r\nconsole.log(Boolean(\"   \\n\")); // true\r\nconsole.log(Boolean(undefined)); // false\r\nconsole.log(Boolean(null)); // true\r\nconsole.log(Boolean({})); // true\r\nconsole.log(Boolean([])); // true\n</code></pre>\n<p>| falsy     | truthy       |\r\n| --------- | ------------ |\r\n| “”        | “foo”        |\r\n| 0,-0      | 23           |\r\n| null      | {a:1}        |\r\n| NaN       | [1,3]        |\r\n| false     | true         |\r\n| undefined | function(){} |</p>\n<h3>Equality and Coercion</h3>\n<p>Usually, we say that in order to not deal with coercion we always use <code>===</code> everywhere and hence we don’t need to think about coercion ever. Is it really true or we are just being ignorant about it? Let’s see.</p>\n<ul>\n<li>We are all familiar with the template literal syntax from the es6 and we use it all over the place. Let’s consider an example to illustrate more</li>\n</ul>\n<pre><code>let numOfStudents = 15;\r\nconsole.log(`Total students are ${numOfStudents}`); // Total students are 15\r\nnumOfStudents = {};\r\nconsole.log(`Total students are ${numOfStudents}`); // Total students are [object Object]\n</code></pre>\n<ul>\n<li>In the code above also the template literal is being coerced to string type by doing the <code>ToString</code> operation and when we see that due to <code>numOfStudents</code> reassigned as <code>object</code> we see the log as <code>[object Object]</code></li>\n</ul>\n<pre><code>let numOfStudents = 15;\r\nlet newStudents = \"4\";\r\nlet newTotal = numOfStudents + newStudents;\r\n\r\nconsole.log(newTotal); // 154\n</code></pre>\n<ul>\n<li>The <code>+</code> operator whenever seeing any of the two elements as a string it prefers string concatenation.</li>\n<li>There are more such places where there is implicit coercion and sometimes we embrace that without even noticing that coercion is taking place and sometimes we make fun of that. However ideal response should be to learn about the language properly rather than thinking it of as some magic.</li>\n</ul>\n<p>Before going let’s look at the code snippet below to see some kind of corner case in javascript and try to find some conclusion base on the idea of abstract operation that we’ve read above.</p>\n<pre><code>console.log(Number(\"\")); // 0\r\nconsole.log(Number(\"  \\t\")); // 0\r\nconsole.log(Number(null)); // 0\r\nconsole.log(Number(undefined)); // NaN\r\nconsole.log(Number([])); // 0\r\nconsole.log(Number([1, 2, 3])); // NaN\r\nconsole.log(Number([null])); // 0\r\nconsole.log(Number([undefined])); // 0\r\nconsole.log(Number({})); // NaN\r\n\r\nconsole.log(String(-0)); // 0\r\nconsole.log(String(null)); // null\r\nconsole.log(String(undefined)); // undefined\r\nconsole.log(String([null])); // \"\"\r\nconsole.log(String([undefined])); // \"\"\r\n\r\nconsole.log(Boolean(new Boolean(false))); // true\r\n\r\nconsole.log(Number(true)); // 1\r\nconsole.log(Number(false)); // 0\r\n\r\nconsole.log(1 &#x3C; 2); // true\r\nconsole.log(2 &#x3C; 3); // true\r\nconsole.log(1 &#x3C; 2 &#x3C; 3); // true\r\n\r\nconsole.log(1 &#x3C; 2 &#x3C; 3); // true\r\nconsole.log(true &#x3C; 3); // true\r\nconsole.log(1 &#x3C; 3); // true\r\n\r\nconsole.log(3 > 2); // true\r\nconsole.log(2 > 1); // true\r\nconsole.log(3 > 2 > 1); // false\r\n\r\nconsole.log(3 > 2 > 1); // false\r\nconsole.log(true > 1); // false\r\nconsole.log(1 > 1); // false\n</code></pre>\n<p>By keeping in mind the corner cases shown below we will see how we can easily learn the difference between <code>==</code> and <code>===</code>.</p>\n<h3>Equality (<code>==</code> vs <code>===</code>)</h3>\n<p>The most common place where we notice coercion is when we use double equal <code>==</code> and hence due to that we have a notion to use <code>===</code> everywhere to <strong>avoid coercion</strong>.</p>\n<ul>\n<li>We have a notion that <code>==</code> checks value or we can call loose equality check whereas <code>===</code> check value as well as the type which is strict equality check</li>\n<li>However, this notion is not totally true. Let’s see how.</li>\n<li>We people have a feeling that implicit mechanism is kind of magical and we tend to equate magic as bad or evil. However, we can think about implicitness as an abstraction.</li>\n<li>Spec for the link: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison\">https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison</a></li>\n<li>When the types match the <code>===</code> and the <code>==</code> are the same</li>\n<li>For <code>===</code> if the types are different then it return false</li>\n<li>The basic difference then when we are using <code>==</code> and <code>===</code> is whether we allow coercion to happen or not</li>\n<li>It also denotes that both <code>==</code> and <code>===</code> check the type but one allows coercion while the other doesn’t</li>\n<li>In the case of two objects having the same value neither <code>==</code> nor the <code>===</code> will return true because they are two different objects at different memory locations and despite having the same type still they return false.</li>\n<li>In the case of <code>==</code> if it is null and undefined then they are equal</li>\n</ul>\n<pre><code>let a = null;\r\nlet b = undefined;\r\n\r\nconsole.log(a == b); // due to array stringifying\n</code></pre>\n<ul>\n<li><code>==</code> prefers a numeric comparison</li>\n<li><code>==</code> always compares two primitive values and if they don’t get a primitive value in either of the two then it does the toPrimitive() operation which first does valueOf() and then toString() to get the result</li>\n<li>We should try to make comparisons mostly by making the type the same whenever it is possible.</li>\n</ul>\n<p><strong>Corner Cases of <code>==</code></strong></p>\n<pre><code>let a = 14;\r\nlet b = [14];\r\n\r\nconsole.log(a == b); // due to array stringifying\r\n\r\nconsole.log([] == ![]); // true\r\n// however we never do such comparison in our real program only place we do in JS is while\r\n// checking a NaN value or something\r\n\r\n// Using Booleans we should not use double equals\r\nlet arr = [];\r\n\r\nconsole.log(arr == true); // false\r\nconsole.log(arr == false); // true\r\nconsole.log(arr === true); // false\n</code></pre>\n<h3>Summary</h3>\n<ul>\n<li>Avoid <code>==</code> with 0 or <code>“”</code> or even <code>“ \"</code></li>\n<li>Avoid using <code>==</code> with non-primitives</li>\n<li>Don’t use <code>==</code> to <code>true</code> and <code>false</code></li>\n<li><code>==</code> is not about comparisons with unknown types</li>\n<li>Always use <code>==</code> when you know the types and optionally if you need to have coercion</li>\n<li>When the types are the same then <code>==</code> is the same as <code>===</code></li>\n<li>If the types are different, the equivalent of one <code>==</code> would be two (or more) <code>===</code> (i.e, slower)</li>\n<li>If you don’t know about the types then to make it an obvious comparison to the reader that there are uncertainty we can use <code>===</code></li>\n<li>Making types known and obvious leads to better code. If types are known, <code>==</code> is best. Otherwise ,fall back to <code>===</code></li>\n</ul>\n<h3>Credits :</h3>\n<ul>\n<li>Deep JS Foundation: <a href=\"https://frontendmasters.com/courses/deep-javascript-v3/\">https://frontendmasters.com/courses/deep-javascript-v3/</a></li>\n</ul>\n<h3>Links and Resources for further reading</h3>\n<ol>\n<li>Specs for Language Types: <a href=\"https://262.ecma-international.org/11.0/#sec-ecmascript-language-types\">https://262.ecma-international.org/11.0/#sec-ecmascript-language-types</a></li>\n<li>Specs for Strict Equality Comparison: <a href=\"https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison\">https://262.ecma-international.org/11.0/#sec-abstract-equality-comparison</a></li>\n<li>ToPrimitive : <a href=\"https://262.ecma-international.org/11.0/#sec-toprimitive\">https://262.ecma-international.org/11.0/#sec-toprimitive</a></li>\n<li>Corner Cases in other languages: <a href=\"https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/\">https://codeblog.jonskeet.uk/2005/10/02/corner-cases-in-java-and-c/</a>.</li>\n<li>valueOf() : <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf</a></li>\n<li>isNaN : <a href=\"https://262.ecma-international.org/11.0/#sec-isnan-number\">https://262.ecma-international.org/11.0/#sec-isnan-number</a></li>\n<li>Number.isNaN : <a href=\"https://262.ecma-international.org/11.0/#sec-number.isnan\">https://262.ecma-international.org/11.0/#sec-number.isnan</a></li>\n<li>A great video showing some weird js behavior that we’ve read above: <a href=\"https://www.youtube.com/watch?v=et8xNAc2ic8\">https://www.youtube.com/watch?v=et8xNAc2ic8</a></li>\n<li>A website containing a lot of weird corner cases of javascript: <a href=\"https://wtfjs.com/\">https://wtfjs.com/</a></li>\n</ol>\n<blockquote>\n<p>If you have any suggestions for improvement please reach out to me at <a href=\"https://twitter.com/RafeeqSyedAmjad\">Twitter</a></p>\n</blockquote>\n","title":"Types and Coercion in JS","description":"A quick guide to types and coercion in JavaScript.","date":"2022-08-15"}},"__N_SSG":true}