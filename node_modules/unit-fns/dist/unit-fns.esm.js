var HALF_PI = Math.PI / 2;

var bounce = function bounce(x) {
  var n1 = 7.5625;
  var d1 = 2.75;

  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    var a = x - 1.5 / d1;
    return n1 * a * a + 0.75;
  } else if (x < 2.5 / d1) {
    var _a = x - 2.25 / d1;

    return n1 * _a * _a + 0.9375;
  } else {
    var _a2 = x - 2.625 / d1;

    return n1 * _a2 * _a2 + 0.984375;
  }
};
var sine = function sine(x) {
  return Math.sin(x * HALF_PI);
};
var cosine = function cosine(x) {
  return Math.cos(x * HALF_PI);
};
var triangle = function triangle(x) {
  return 1 - Math.abs(x * 2 - 1);
};
var center = function center(x) {
  return Math.abs(x * 2 - 1);
};
var circular = function circular(x) {
  return 1 - Math.sqrt(1 - Math.pow(x, 2));
};
var invert = function invert(x) {
  return 1 - x;
};
var exponential = function exponential(x) {
  return x === 0 ? 0 : Math.pow(2, 10 * x - 10);
};
var linear = function linear(x) {
  return x;
};
var quadratic = function quadratic(x) {
  return x * x;
};
var cubic = function cubic(x) {
  return x * x * x;
};
var quartic = function quartic(x) {
  return x * x * x * x;
};
var quintic = function quintic(x) {
  return x * x * x * x * x;
};

var _unary = {
  __proto__: null,
  bounce: bounce,
  sine: sine,
  cosine: cosine,
  triangle: triangle,
  center: center,
  circular: circular,
  invert: invert,
  exponential: exponential,
  linear: linear,
  quadratic: quadratic,
  cubic: cubic,
  quartic: quartic,
  quintic: quintic
};

var isUnit = function isUnit(value) {
  return value >= 0 && value <= 1;
};
var unitMax = 1;
var unitMin = 0;

var clip = function clip(value) {
  return Math.max(0, Math.min(1, value));
};
var degreesToUnit = function degreesToUnit(degrees) {
  return wrap(degrees / 360);
};
var fraction = function fraction(value) {
  return 1 / value;
};
var fractional = function fractional(value) {
  return Math.abs(value % 1);
};
var mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
};
var mapToUnit = function mapToUnit(inMin, inMax, value) {
  return mapRange(inMin, inMax, 0, 1, value);
};
var radiansToUnit = function radiansToUnit(radians) {
  return wrap(radians / HALF_PI);
};
var toIndex = function toIndex(length, unit) {
  return Math.floor(unit * (length - 1));
};
var wrap = function wrap(value) {
  if (isUnit(value)) return value;
  return value < 0 ? 1 - -value % 1 : value % 1;
};
var wrapInclusive = function wrapInclusive(value) {
  if (isUnit(value)) return value;
  if (value % 1 === 0) return 1;
  return value < 0 ? 1 - -value % 1 : value % 1;
};

var angle = function angle(x, y) {
  return radiansToUnit(Math.atan(y / x));
};
var distance = function distance(x, y) {
  return Math.sqrt(x * x + y * y) / Math.SQRT2;
};
var maximum = Math.max;
var minimum = Math.min;
var offset = function offset(amount, unit) {
  return wrapInclusive(amount + unit);
};
var peak = function peak(_peak, unit) {
  return unit < _peak ? unit / _peak : (unit - _peak) * -1 / (1 - _peak) + 1;
}; // TODO: is this unit and should it be in this dir?

var radial = function radial(x, y) {
  return 1 - distance(x * 2 - 1, y * 2 - 1);
};
var repeat = function repeat(scale, t) {
  var times = 1 / scale;
  return t * times % 1;
};
var threshold = function threshold(_threshold, t) {
  return t < _threshold ? unitMin : unitMax;
};
var multiply = function multiply(a, b) {
  return a * b;
};
var screen = function screen(a, b) {
  return 1 - (1 - a) * (1 - b);
};
var darken = function darken(a, b) {
  return Math.min(a, b);
};
var lighten = function lighten(a, b) {
  return Math.max(a, b);
};
var difference = function difference(a, b) {
  return Math.abs(a - b);
};
var exclusion = function exclusion(a, b) {
  return a + b - 2 * a * b;
};
var overlay = function overlay(a, b) {
  return a < 0.5 ? 2.0 * a * b : 1.0 - 2.0 * (1.0 - a) * (1.0 - b);
};
var hardLight = function hardLight(a, b) {
  return b < 0.5 ? 2.0 * a * b : 1.0 - 2.0 * (1.0 - a) * (1.0 - b);
};
var softLight = function softLight(a, b) {
  return b < 0.5 ? 2.0 * a * b + a * a * (1.0 - 2.0 * b) : Math.sqrt(a) * (2.0 * b - 1.0) + 2.0 * a * (1.0 - b);
};
var colorDodge = function colorDodge(a, b) {
  return a / (1.0 - b);
};
var linearDodge = function linearDodge(a, b) {
  return a + b;
};
var burn = function burn(a, b) {
  return 1.0 - (1 - a) / b;
};
var linearBurn = function linearBurn(a, b) {
  return a + b - 1.0;
};

var _binary = {
  __proto__: null,
  angle: angle,
  distance: distance,
  maximum: maximum,
  minimum: minimum,
  offset: offset,
  peak: peak,
  radial: radial,
  repeat: repeat,
  threshold: threshold,
  multiply: multiply,
  screen: screen,
  darken: darken,
  lighten: lighten,
  difference: difference,
  exclusion: exclusion,
  overlay: overlay,
  hardLight: hardLight,
  softLight: softLight,
  colorDodge: colorDodge,
  linearDodge: linearDodge,
  burn: burn,
  linearBurn: linearBurn
};

var clamp = function clamp(min, max, val) {
  return val > max ? max : val < min ? min : val;
};
var mix = function mix(outMin, outMax, unit) {
  return outMin * (1 - unit) + outMax * unit;
}; // TODO: rename to step

var toggle = function toggle(a, b, t) {
  return t < 0.5 ? a : b;
};

var _ternary = {
  __proto__: null,
  clamp: clamp,
  mix: mix,
  toggle: toggle
};

var branch = function branch(a, b, unit) {
  return unit > 0.5 ? b(unit) : a(unit);
};
var fit = function fit(fns, unit) {
  var fnsLength = fns.length;
  var t = repeat(fraction(fnsLength), unit);
  var fn = fns[toIndex(fnsLength, unit)];
  return fn(t);
};
var fitSteps = function fitSteps(steps, unit) {
  return steps[toIndex(steps.length, unit)];
};
var createBands = function createBands(fn) {
  return function (fraction, value) {
    if (fraction === 0) return value;
    var bands = unitMax / fraction;
    return fn(value * bands) / bands;
  };
};
var quantize = /*#__PURE__*/createBands(Math.floor);
var sampleUnaryFn = function sampleUnaryFn(length, onSample) {
  var lookupTable = Array(length);

  for (var i = 0; i < length; i++) {
    lookupTable[i] = onSample(i / length);
  }

  return lookupTable;
};
var lookup = function lookup(unit, lookupTable) {
  return lookupTable[toIndex(lookupTable.length, unit)];
};
var createTiles = function createTiles(gridX, gridY, fn3d) {
  var fractionX = 1 / gridX;
  var fractionY = 1 / gridY;
  var frac = 2 / (gridX + gridY);
  return function (x, y) {
    var z = quantize(fractionY, y) + quantize(fractionX, x) * frac;
    return fn3d(repeat(fractionX, x), repeat(fractionY, y), z);
  };
};

var unary = _unary;
var binary = _binary;
var ternary = _ternary;
// https://iquilezles.org/articles/functions/
// http://www.flong.com/archive/texts/code/shapers_poly/
// http://www.flong.com/archive/texts/code/shapers_exp/
// http://www.flong.com/archive/texts/code/shapers_circ/

export { angle, binary, bounce, branch, burn, center, circular, clamp, clip, colorDodge, cosine, createBands, createTiles, cubic, darken, degreesToUnit, difference, distance, exclusion, exponential, fit, fitSteps, fraction, fractional, hardLight, invert, isUnit, lighten, linear, linearBurn, linearDodge, lookup, mapRange, mapToUnit, maximum, minimum, mix, multiply, offset, overlay, peak, quadratic, quantize, quartic, quintic, radial, radiansToUnit, repeat, sampleUnaryFn, screen, sine, softLight, ternary, threshold, toIndex, toggle, triangle, unary, unitMax, unitMin, wrap, wrapInclusive };
//# sourceMappingURL=unit-fns.esm.js.map
